diff -urN linux-4.18-patched/arch/riscv/kernel/time.c riscv-linux-riscv-linux-4.18/arch/riscv/kernel/time.c
--- linux-4.18-patched/arch/riscv/kernel/time.c	2018-09-16 13:22:58.174500432 +0100
+++ riscv-linux-riscv-linux-4.18/arch/riscv/kernel/time.c	2018-09-16 12:59:54.517926037 +0100
@@ -20,14 +20,6 @@
 
 void __init time_init(void)
 {
-	struct device_node *cpu;
-	u32 prop;
-
-	cpu = of_find_node_by_path("/cpus");
-	if (!cpu || of_property_read_u32(cpu, "timebase-frequency", &prop))
-		panic(KERN_WARNING "RISC-V system with no 'timebase-frequency' in DTS\n");
-	riscv_timebase = prop;
-
-	lpj_fine = riscv_timebase / HZ;
 	timer_probe();
+	lpj_fine = riscv_timebase / HZ;
 }
Binary files linux-4.18-patched/arch/riscv/kernel/vdso/vdso-dummy.o.tmp and riscv-linux-riscv-linux-4.18/arch/riscv/kernel/vdso/vdso-dummy.o.tmp differ
Binary files linux-4.18-patched/arch/riscv/kernel/vdso/vdso.so.dbg.tmp and riscv-linux-riscv-linux-4.18/arch/riscv/kernel/vdso/vdso.so.dbg.tmp differ
diff -urN linux-4.18-patched/drivers/clocksource/riscv_timer.c riscv-linux-riscv-linux-4.18/drivers/clocksource/riscv_timer.c
--- linux-4.18-patched/drivers/clocksource/riscv_timer.c	2018-09-16 13:22:58.178500295 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/clocksource/riscv_timer.c	2018-09-16 13:02:50.439903478 +0100
@@ -82,6 +82,21 @@
 	evdev->event_handler(evdev);
 }
 
+static long __init riscv_timebase_frequency(struct device_node *node)
+{
+	u32 timebase;
+
+	if (!of_property_read_u32(node, "timebase-frequency", &timebase))
+		return timebase;
+
+	/* check under parent "cpus" node */
+	if (!of_property_read_u32(node->parent, "timebase-frequency",
+				  &timebase))
+		return timebase;
+
+	panic("RISC-V system with no 'timebase-frequency' in DTS\n");
+}
+
 static int __init riscv_timer_init_dt(struct device_node *n)
 {
 	int cpu_id = riscv_of_processor_hart(n), error;
@@ -90,6 +105,7 @@
 	if (cpu_id != smp_processor_id())
 		return 0;
 
+	riscv_timebase = riscv_timebase_frequency(n);
 	cs = per_cpu_ptr(&riscv_clocksource, cpu_id);
 	clocksource_register_hz(cs, riscv_timebase);
 
diff -urN linux-4.18-patched/drivers/input/keyboard/Kconfig riscv-linux-riscv-linux-4.18/drivers/input/keyboard/Kconfig
--- linux-4.18-patched/drivers/input/keyboard/Kconfig	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/input/keyboard/Kconfig	2018-09-16 10:03:48.048206866 +0100
@@ -757,3 +757,11 @@
 	  module will be called pmic-keys.
 
 endif
+
+config KEYBOARD_LOWRISC
+	tristate "LowRISC keyboard"
+	select INPUT_POLLDEV
+	default n
+	help
+	  Say Y here if you want to use a LowRISC keyboard.
+	  If unsure, say N.
diff -urN linux-4.18-patched/drivers/input/keyboard/lowrisc-fake-keys.c riscv-linux-riscv-linux-4.18/drivers/input/keyboard/lowrisc-fake-keys.c
--- linux-4.18-patched/drivers/input/keyboard/lowrisc-fake-keys.c	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/input/keyboard/lowrisc-fake-keys.c	2018-08-18 10:23:33.823492000 +0100
@@ -0,0 +1,273 @@
+/*
+ * Lowrisc Dummy Keyboard Controller Driver - Translates UART input to fake key events
+ * http://www.lowrisc.org/
+ *
+ * based on opencores Javier Herrero <jherrero@hvsistemas.es>
+ * Copyright 2007-2009 HV Sistemas S.L.
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ * This driver acts as a shadow console, forwarding serial port events to the main console
+ * using the input event mechanism. It's primary use is to allow LowRISC to be used via
+ * a serial port without screen and keyboard being connected.
+ *
+ * It also may be used as a conduit to shadow an approximation of console output to the serial port
+ *
+ * Since console output is already processed according to the type of device at this point, it would
+ * be too complicated to replicate all the behaviour of a serial console. So everything other than
+ * emergency hacking should be done via ssh (for editing) or sftp (for uploading)
+ */
+
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/input-polldev.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <asm/sbi.h>
+
+#define DRIVER_NAME "lowrisc-fake"
+
+static struct lowrisc_fake {
+  struct platform_device *pdev;
+  struct resource *fake;
+  spinlock_t lock;
+  volatile uint32_t *fake_base;
+  struct input_dev *input;
+  unsigned short keycodes[128];
+} lowrisc_fake_static;
+
+void lowrisc_shadow_console_putchar(int ch)
+{
+  volatile uint64_t *tx = (volatile uint64_t *)(lowrisc_fake_static.fake_base);
+  if (tx)
+    {
+      *tx = ch & 0x7f; /* just send the US ASCII subset */
+    }
+  else /* probe function not called yet */
+    {
+      sbi_console_putchar(ch);
+    }
+}
+
+static int upper(int ch)
+{
+  if ( ch >= 'A' && ch <= 'Z' ) return 1;
+  switch ( ch )
+    {
+    case '!' : return 1;
+    case '"' : return 1;
+    case '#' : return 1;
+    case '$' : return 1;
+    case '%' : return 1;
+    case '^' : return 1;
+    case '&' : return 1;
+    case '*' : return 1;
+    case '<' : return 1;
+    case '>' : return 1;
+    case '~' : return 1;
+    case '@' : return 1;
+    case '+' : return 1;
+    case '_' : return 1;
+    case '(' : return 1;
+    case ')' : return 1;
+    case '{' : return 1;
+    case '}' : return 1;
+    case '|' : return 1;
+    case ':' : return 1;
+    case '?' : return 1;
+    default  : return 0;
+    }
+}
+
+static void lowrisc_keys_poll(struct input_polled_dev *dev)
+{
+  struct lowrisc_fake *lowrisc_fake = dev->private;
+  struct input_dev *input = dev->input;
+  unsigned char c;
+  volatile uint64_t *rx = (volatile uint64_t *)(lowrisc_fake->fake_base);
+  int ch = *rx;
+  if (0x200 & ~ch)
+    {
+      enum {lctrl=0x1d, lshift=0x2a};
+      int ctrl;
+      rx[0x200] = 0; // pop FIFO
+      ch = *rx & 0x7f;
+      ctrl = ch >= 1 && ch <= 26;
+      if (ctrl)
+	{
+	  input_report_key(input, lctrl, 1);
+          ch = ch + 'a' - 1; // Convert ctrl-key back to normal key
+	}      
+      switch(ch)
+	{
+	case '\e' : c =  	  0x01; break;
+	case '1' : case '!' : c = 0x02; break;
+	case '2' : case '@' : c =  	  0x03; break;
+	case '3' : case '#' : c =  	  0x04; break;
+	case '4' : case '$' : c =  	  0x05; break;
+	case '5' : case '%' : c =  	  0x06; break;
+	case '6' : case '^' : c =  	  0x07; break;
+	case '7' : case '&' : c =  	  0x08; break;
+	case '8' : case '*' : c =  	  0x09; break;
+	case '9' : case '(' : c =  	  0x0a; break;
+	case '0' : case ')' : c =  	      0x0b; break;
+	case '-' : case '_' : c =  	  0x0c; break;
+	case '=' : case '+' : c =  	  0x0d; break;
+	case 0x7f : c = 0x0e; break;
+	case '\t' : c = 0x0f; break;
+	case 'Q' : case 'q' : c =  	  0x10; break;
+	case 'W' : case 'w' : c =  	  0x11; break;
+	case 'E' : case 'e' : c =  	  0x12; break;
+	case 'R' : case 'r' : c =  	  0x13; break;
+	case 'T' : case 't' : c =  	  0x14; break;
+	case 'Y' : case 'y' : c =  	  0x15; break;
+	case 'U' : case 'u' : c =  	  0x16; break;
+	case 'I' : case 'i' : c =  	  0x17; break;
+	case 'O' : case 'o' : c =  	  0x18; break;
+	case 'P' : case 'p' : c =  	  0x19; break;
+	case '[' : case '{' : c =  	  0x1a; break;
+	case ']' : case '}' : c =  	  0x1b; break;
+	case '\r' : c =  	  0x1c; break;
+	case 'A' : case 'a' : c =  	  0x1e; break;
+	case 'S' : case 's' : c =  	  0x1f; break;
+	case 'D' : case 'd' : c =  	  0x20; break;
+	case 'F' : case 'f' : c =  	  0x21; break;
+	case 'G' : case 'g' : c =  	  0x22; break;
+	case 'H' : case 'h' : c =  	  0x23; break;
+	case 'J' : case 'j' : c =  	  0x24; break;
+	case 'K' : case 'k' : c =  	  0x25; break;
+	case 'L' : case 'l' : c =  	  0x26; break;
+	case ';' : case ':' : c =  	  0x27; break;
+	case '\'' : case '"' : c =  	  0x28; break;
+	case '`' : case '~' : c =  	  0x29; break;
+	case '\\' : case '|' : c =  	  0x2b; break;
+	case 'Z' : case 'z' : c =   0x2c; break;
+	case 'X' : case 'x' : c =   0x2d; break;
+	case 'C' : case 'c' : c =   0x2e; break;
+	case 'V' : case 'v' : c =   0x2f; break;
+	case 'B' : case 'b' : c =   0x30; break;
+	case 'N' : case 'n' : c =   0x31; break;
+	case 'M' : case 'm' : c =   0x32; break;
+	case ',' : case '<' : c =   0x33; break;
+	case '.' : case '>' : c =   0x34; break;
+	case '/' : case '?' : c =   0x35; break;
+	case ' ' : c =   0x39; break;
+	default: c = 0; printk("input_report_key 0x%x not translated\n", ch);
+	}
+      if (upper(ch))
+	{
+	  input_report_key(input, lshift, 1);
+	}
+      input_report_key(input, c, 1);
+      input_report_key(input, c, 0);
+      if (ctrl)
+	{
+	  input_report_key(input, lctrl, 0);
+	}
+      if (upper(ch))
+	{
+	  input_report_key(input, lshift, 0);
+	}
+      input_sync(input);
+    }
+}
+
+static int lowrisc_fake_probe(struct platform_device *pdev)
+{
+  struct input_dev *input;
+  struct lowrisc_fake *lowrisc_fake;
+  int i, error;
+  struct input_polled_dev *poll_dev;
+  struct device *dev = &pdev->dev;
+
+  printk("lowrisc_fake_probe\n");
+  lowrisc_fake = &lowrisc_fake_static;
+  
+  if (lowrisc_fake->fake_base) /* Only one instance allowed */
+    {
+    return -ENOMEM;
+    }
+
+  lowrisc_fake->fake = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  if (!request_mem_region(lowrisc_fake->fake->start, resource_size(lowrisc_fake->fake), "lowrisc_fake"))
+    {
+    dev_err(&pdev->dev, "cannot request LowRISC UART region\n");
+    return -EBUSY;
+    }
+
+  lowrisc_fake->fake_base = (volatile uint32_t *)ioremap(lowrisc_fake->fake->start, resource_size(lowrisc_fake->fake));
+  printk("fake_keyboard address %llx, remapped to %lx\n", lowrisc_fake->fake->start, (size_t)lowrisc_fake->fake_base);
+
+  poll_dev = devm_input_allocate_polled_device(dev);
+  if (!poll_dev) {
+    dev_err(dev, "failed to allocate input device\n");
+    return -ENOMEM;
+  }
+  
+  poll_dev->poll_interval = 100;
+  
+  poll_dev->poll = lowrisc_keys_poll;
+  poll_dev->private = lowrisc_fake;
+  
+  input = poll_dev->input;
+
+  lowrisc_fake->input = input;
+
+  input->name = pdev->name;
+  input->phys = "lowrisc-fake/input0";
+  
+  input->id.bustype = BUS_HOST;
+  input->id.vendor = 0x0001;
+  input->id.product = 0x0001;
+  input->id.version = 0x0100;
+  
+  input->keycode = lowrisc_fake->keycodes;
+  input->keycodesize = sizeof(lowrisc_fake->keycodes[0]);
+  input->keycodemax = ARRAY_SIZE(lowrisc_fake->keycodes);
+  
+  __set_bit(EV_KEY, input->evbit);
+  
+  for (i = 0; i < ARRAY_SIZE(lowrisc_fake->keycodes); i++) {
+    /*
+     * Lowrisc lowrisc_faketroller happens to have scancodes match
+     * our KEY_* definitions.
+     */
+    lowrisc_fake->keycodes[i] = i;
+    __set_bit(lowrisc_fake->keycodes[i], input->keybit);
+  }
+  __clear_bit(KEY_RESERVED, input->keybit);
+  
+  error = input_register_polled_device(poll_dev);
+  if (error) {
+    dev_err(dev, "Unable to register input device: %d\n", error);
+    return error;
+  }
+ 
+  return 0;
+}
+
+static const struct of_device_id lowrisc_fake_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, lowrisc_fake_of_match);
+
+static struct platform_driver lowrisc_fake_device_driver = {
+	.probe    = lowrisc_fake_probe,
+	.driver   = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_fake_of_match,
+	},
+};
+module_platform_driver(lowrisc_fake_device_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jonathan Kimmitt <jonathan@kimmitt.uk>");
+MODULE_DESCRIPTION("Dummy Keyboard input events for Lowrisc");
diff -urN linux-4.18-patched/drivers/input/keyboard/lowrisc-kbd.c riscv-linux-riscv-linux-4.18/drivers/input/keyboard/lowrisc-kbd.c
--- linux-4.18-patched/drivers/input/keyboard/lowrisc-kbd.c	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/input/keyboard/lowrisc-kbd.c	2018-08-18 10:23:33.823492000 +0100
@@ -0,0 +1,166 @@
+/*
+ * Lowrisc Keyboard Controller Driver
+ * http://www.lowrisc.org/
+ *
+ * based on opencores Javier Herrero <jherrero@hvsistemas.es>
+ * Copyright 2007-2009 HV Sistemas S.L.
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ * This driver polls the Nexys4DDR onboard PIC which has a PS/2 to USB converter for legacy keyboards
+ * Newer keyboards such as Apple USB do not use PS/2 emulation so you are out of luck.
+ * This driver was tested with a Microsoft Wired Keyboard 200, which meets the above criterion.
+ * Alternatively PS/2 keyboards that have a USB adaptor plug would probably be suitable (but untested)
+ *
+ * The Verilog sub-system generates raw scancodes which this driver converts to PC standard codes, and
+ * the input subsystem then converts them to ASCII according National/Regional preferences.
+ *
+ * There may be missing or incorrect codes which can be corrected in RTL, but the PIC programming is not
+ * open source as far as I am aware, so unhappy users should use the lowrisc-fake-keys.c driver which
+ * emulates serial events for all keyboards over the serial port. In the latter case the USB port is free
+ * to attach a mouse or similar device, but emulation speeds are too limited for effective graphical console
+ * use (and VGA graphics RTL would have to be designed).
+ */
+
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/input-polldev.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <asm/sbi.h>
+
+#define DRIVER_NAME "lowrisc-keyb"
+
+struct lowrisc_kbd {
+  struct platform_device *pdev;
+  struct resource *keyb;
+  spinlock_t lock;
+  volatile uint32_t *keyb_base;
+  struct input_dev *input;
+  unsigned short keycodes[128];
+};
+
+const struct { char scan,lwr,upr; } scancode[] = {
+#include "lowrisc-scancode.h"
+};
+
+static void lowrisc_keys_poll(struct input_polled_dev *dev)
+{
+  struct lowrisc_kbd *lowrisc_kbd = dev->private;
+  struct input_dev *input = dev->input;
+  unsigned char c;
+  uint32_t key = *lowrisc_kbd->keyb_base;
+  if ((1<<9) & ~key)
+    {
+      *lowrisc_kbd->keyb_base = 0; // bump FIFO location
+      key = *lowrisc_kbd->keyb_base & ~0x200;
+      c = scancode[key&~0x100].scan; /* convert to standard AT keyboard codes */
+      if (c != 0x3A) // Ignore caps lock for now (and hopefully always)
+        {
+          input_report_key(input, c, key & 0x100 ? 0 : 1);
+          input_sync(input);
+        }
+      pr_debug("input event key %c\n", scancode[key&~0x100].lwr);
+    }
+}
+
+static int lowrisc_kbd_probe(struct platform_device *pdev)
+{
+  struct input_dev *input;
+  struct lowrisc_kbd *lowrisc_kbd;
+  int i, error;
+  struct input_polled_dev *poll_dev;
+  struct device *dev = &pdev->dev;
+
+  printk("lowrisc_kbd_probe\n");
+  lowrisc_kbd = devm_kzalloc(&pdev->dev, sizeof(struct lowrisc_kbd), GFP_KERNEL);
+  if (!lowrisc_kbd) {
+    return -ENOMEM;
+  }
+  lowrisc_kbd->keyb = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  if (!request_mem_region(lowrisc_kbd->keyb->start, resource_size(lowrisc_kbd->keyb), "lowrisc_kbd"))
+    {
+    dev_err(&pdev->dev, "cannot request LowRISC keyboard region\n");
+    return -EBUSY;
+    }
+  lowrisc_kbd->keyb_base = (volatile uint32_t *)ioremap(lowrisc_kbd->keyb->start, resource_size(lowrisc_kbd->keyb));
+  printk("hid_keyboard address %llx, remapped to %lx\n", lowrisc_kbd->keyb->start, (size_t)lowrisc_kbd->keyb_base);
+
+  poll_dev = devm_input_allocate_polled_device(dev);
+  if (!poll_dev) {
+    dev_err(dev, "failed to allocate input device\n");
+    return -ENOMEM;
+  }
+  
+  poll_dev->poll_interval = 100;
+  
+  poll_dev->poll = lowrisc_keys_poll;
+  poll_dev->private = lowrisc_kbd;
+  
+  input = poll_dev->input;
+
+  lowrisc_kbd->input = input;
+
+  input->name = pdev->name;
+  input->phys = "lowrisc-kbd/input0";
+  
+  input->id.bustype = BUS_HOST;
+  input->id.vendor = 0x0001;
+  input->id.product = 0x0001;
+  input->id.version = 0x0100;
+  
+  input->keycode = lowrisc_kbd->keycodes;
+  input->keycodesize = sizeof(lowrisc_kbd->keycodes[0]);
+  input->keycodemax = ARRAY_SIZE(lowrisc_kbd->keycodes);
+  
+  __set_bit(EV_KEY, input->evbit);
+  
+  for (i = 0; i < ARRAY_SIZE(lowrisc_kbd->keycodes); i++) {
+    /*
+     * Lowrisc lowrisc_kbdtroller happens to have scancodes match
+     * our KEY_* definitions.
+     */
+    lowrisc_kbd->keycodes[i] = i;
+    __set_bit(lowrisc_kbd->keycodes[i], input->keybit);
+  }
+  __clear_bit(KEY_RESERVED, input->keybit);
+  
+  error = input_register_polled_device(poll_dev);
+  if (error) {
+    dev_err(dev, "Unable to register input device: %d\n", error);
+    return error;
+  }
+  printk("Clear any pending input\n");
+  while ((1<<9) & ~*lowrisc_kbd->keyb_base)
+    {
+      *lowrisc_kbd->keyb_base = 0; // bump FIFO location
+    }
+  printk("Loading keyboard input device returns success\n");  
+  return 0;
+}
+
+static const struct of_device_id lowrisc_kbd_of_match[] = {
+	{ .compatible = "lowrisc-keyb" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, lowrisc_kbd_of_match);
+
+static struct platform_driver lowrisc_kbd_device_driver = {
+	.probe    = lowrisc_kbd_probe,
+	.driver   = {
+		.name = "lowrisc-keyb",
+		.of_match_table = lowrisc_kbd_of_match,
+	},
+};
+module_platform_driver(lowrisc_kbd_device_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jonathan Kimmitt <jonathan@kimmitt.uk>");
+MODULE_DESCRIPTION("Keyboard driver for Lowrisc Keyboard Lowrisc_controller");
diff -urN linux-4.18-patched/drivers/input/keyboard/lowrisc-scancode.h riscv-linux-riscv-linux-4.18/drivers/input/keyboard/lowrisc-scancode.h
--- linux-4.18-patched/drivers/input/keyboard/lowrisc-scancode.h	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/input/keyboard/lowrisc-scancode.h	2018-08-18 10:23:33.823492000 +0100
@@ -0,0 +1,282 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// A table of PS/2 to AT scan code conversions,                 ////
+//// based on ps2_defines.v                                       ////
+//// Copyright (C) 2000 Miha Dolenc, mihad@opencores.org          ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+[  0] = {0x00,0x00,0x00},
+[  1] = {0x43,0x00,0x00},
+[  2] = {0x41,0x00,0x00},
+[  3] = {0x3f,0x00,0x00},
+[  4] = {0x3d,0x00,0x00},
+[  5] = {0x3b,0x00,0x00},
+[  6] = {0x3c,0x00,0x00},
+[  7] = {0x58,0x00,0x00},
+[  8] = {0x64,0x00,0x00},
+[  9] = {0x44,0x00,0x00},
+[ 10] = {0x42,0x00,0x00},
+[ 11] = {0x40,0x00,0x00},
+[ 12] = {0x3e,0x00,0x00},
+[ 13] = {0x0f,0x09,0x09},
+[ 14] = {0x29,0x60,0x60},
+[ 15] = {0x59,0x00,0x00},
+[ 16] = {0x65,0x00,0x00},
+[ 17] = {0x38,0x00,0x00},
+[ 18] = {0x2a,0x00,0x00},
+[ 19] = {0x70,0x00,0x00},
+[ 20] = {0x1d,0x00,0x00},
+[ 21] = {0x10,0x71,0x51},
+[ 22] = {0x02,0x31,0x21},
+[ 23] = {0x5a,0x00,0x00},
+[ 24] = {0x66,0x00,0x00},
+[ 25] = {0x71,0x00,0x00},
+[ 26] = {0x2c,0x7a,0x5a},
+[ 27] = {0x1f,0x73,0x53},
+[ 28] = {0x1e,0x61,0x41},
+[ 29] = {0x11,0x77,0x57},
+[ 30] = {0x03,0x32,0x22},
+[ 31] = {0x5b,0x00,0x00},
+[ 32] = {0x67,0x00,0x00},
+[ 33] = {0x2e,0x63,0x43},
+[ 34] = {0x2d,0x78,0x58},
+[ 35] = {0x20,0x64,0x44},
+[ 36] = {0x12,0x65,0x45},
+[ 37] = {0x05,0x34,0x24},
+[ 38] = {0x04,0x33,0x23},
+[ 39] = {0x5c,0x00,0x00},
+[ 40] = {0x68,0x00,0x00},
+[ 41] = {0x39,0x20,0x20},
+[ 42] = {0x2f,0x76,0x56},
+[ 43] = {0x21,0x66,0x46},
+[ 44] = {0x14,0x74,0x54},
+[ 45] = {0x13,0x72,0x52},
+[ 46] = {0x06,0x35,0x25},
+[ 47] = {0x5d,0x00,0x00},
+[ 48] = {0x69,0x00,0x00},
+[ 49] = {0x31,0x6e,0x4e},
+[ 50] = {0x30,0x62,0x42},
+[ 51] = {0x23,0x68,0x48},
+[ 52] = {0x22,0x67,0x47},
+[ 53] = {0x15,0x79,0x59},
+[ 54] = {0x07,0x36,0x5e},
+[ 55] = {0x5e,0x00,0x00},
+[ 56] = {0x6a,0x00,0x00},
+[ 57] = {0x72,0x00,0x00},
+[ 58] = {0x32,0x6d,0x4d},
+[ 59] = {0x24,0x6a,0x4a},
+[ 60] = {0x16,0x75,0x55},
+[ 61] = {0x08,0x37,0x26},
+[ 62] = {0x09,0x38,0x2a},
+[ 63] = {0x5f,0x00,0x00},
+[ 64] = {0x6b,0x00,0x00},
+[ 65] = {0x33,0x2c,0x3c},
+[ 66] = {0x25,0x6b,0x4b},
+[ 67] = {0x17,0x69,0x49},
+[ 68] = {0x18,0x6f,0x4f},
+[ 69] = {0x0b,0x30,0x29},
+[ 70] = {0x0a,0x39,0x28},
+[ 71] = {0x60,0x00,0x00},
+[ 72] = {0x6c,0x00,0x00},
+[ 73] = {0x34,0x2e,0x3e},
+[ 74] = {0x35,0x2f,0x3f},
+[ 75] = {0x26,0x6c,0x4c},
+[ 76] = {0x27,0x3b,0x3a},
+[ 77] = {0x19,0x70,0x50},
+[ 78] = {0x0c,0x2d,0x5f},
+[ 79] = {0x61,0x00,0x00},
+[ 80] = {0x6d,0x00,0x00},
+[ 81] = {0x73,0x00,0x00},
+[ 82] = {0x28,0x27,0x40},
+[ 83] = {0x74,0x00,0x00},
+[ 84] = {0x1a,0x5b,0x7b},
+[ 85] = {0x0d,0x3d,0x2b},
+[ 86] = {0x62,0x00,0x00},
+[ 87] = {0x6e,0x00,0x00},
+[ 88] = {0x3a,0x00,0x00},
+[ 89] = {0x36,0x00,0x00},
+[ 90] = {0x1c,0x0d,0x0d},
+[ 91] = {0x1b,0x5d,0x7d},
+[ 92] = {0x75,0x00,0x00},
+[ 93] = {0x2b,0x5c,0x7c},
+[ 94] = {0x63,0x00,0x00},
+[ 95] = {0x76,0x00,0x00},
+[ 96] = {0x55,0x00,0x00},
+[ 97] = {0x56,0x00,0x00},
+[ 98] = {0x77,0x00,0x00},
+[ 99] = {0x78,0x00,0x00},
+[100] = {0x79,0x00,0x00},
+[101] = {0x7a,0x00,0x00},
+[102] = {0x0e,0x08,0x08},
+[103] = {0x7b,0x00,0x00},
+[104] = {0x7c,0x00,0x00},
+[105] = {0x4f,0x00,0x00},
+[106] = {0x7d,0x00,0x00},
+[107] = {0x4b,0x00,0x00},
+[108] = {0x47,0x00,0x00},
+[109] = {0x7e,0x00,0x00},
+[110] = {0x7f,0x00,0x00},
+[111] = {0x6f,0x00,0x00},
+[112] = {0x52,0x00,0x00},
+[113] = {0x53,0x00,0x00},
+[114] = {0x50,0x00,0x00},
+[115] = {0x4c,0x00,0x00},
+[116] = {0x4d,0x00,0x00},
+[117] = {0x48,0x00,0x00},
+[118] = {0x01,0x1b,0x1b},
+[119] = {0x45,0x00,0x00},
+[120] = {0x57,0x00,0x00},
+[121] = {0x4e,0x2b,0x2b},
+[122] = {0x51,0x00,0x00},
+[123] = {0x4a,0x2d,0x5f},
+[124] = {0x37,0x2a,0x2a},
+[125] = {0x49,0x00,0x00},
+[126] = {0x46,0x00,0x00},
+[127] = {0x54,0x00,0x00},
+[128] = {0x80,0x00,0x00},
+[129] = {0x81,0x1b,0x1b},
+[130] = {0x82,0x31,0x21},
+[131] = {0x41,0x00,0x00},
+[132] = {0x54,0x00,0x00},
+[133] = {0x85,0x34,0x24},
+[134] = {0x86,0x35,0x25},
+[135] = {0x87,0x36,0x5e},
+[136] = {0x88,0x37,0x26},
+[137] = {0x89,0x38,0x2a},
+[138] = {0x8a,0x39,0x28},
+[139] = {0x8b,0x30,0x29},
+[140] = {0x8c,0x2d,0x5f},
+[141] = {0x8d,0x3d,0x2b},
+[142] = {0x8e,0x08,0x08},
+[143] = {0x8f,0x09,0x09},
+[144] = {0x90,0x71,0x51},
+[145] = {0x91,0x77,0x57},
+[146] = {0x92,0x65,0x45},
+[147] = {0x93,0x72,0x52},
+[148] = {0x94,0x74,0x54},
+[149] = {0x95,0x79,0x59},
+[150] = {0x96,0x75,0x55},
+[151] = {0x97,0x69,0x49},
+[152] = {0x98,0x6f,0x4f},
+[153] = {0x99,0x70,0x50},
+[154] = {0x9a,0x5b,0x7b},
+[155] = {0x9b,0x5d,0x7d},
+[156] = {0x9c,0x0d,0x0d},
+[157] = {0x9d,0x00,0x00},
+[158] = {0x9e,0x61,0x41},
+[159] = {0x9f,0x73,0x53},
+[160] = {0xa0,0x64,0x44},
+[161] = {0xa1,0x66,0x46},
+[162] = {0xa2,0x67,0x47},
+[163] = {0xa3,0x68,0x48},
+[164] = {0xa4,0x6a,0x4a},
+[165] = {0xa5,0x6b,0x4b},
+[166] = {0xa6,0x6c,0x4c},
+[167] = {0xa7,0x3b,0x3a},
+[168] = {0xa8,0x27,0x40},
+[169] = {0xa9,0x60,0x60},
+[170] = {0xaa,0x00,0x00},
+[171] = {0xab,0x5c,0x7c},
+[172] = {0xac,0x7a,0x5a},
+[173] = {0xad,0x78,0x58},
+[174] = {0xae,0x63,0x43},
+[175] = {0xaf,0x76,0x56},
+[176] = {0xb0,0x62,0x42},
+[177] = {0xb1,0x6e,0x4e},
+[178] = {0xb2,0x6d,0x4d},
+[179] = {0xb3,0x2c,0x3c},
+[180] = {0xb4,0x2e,0x3e},
+[181] = {0xb5,0x2f,0x3f},
+[182] = {0xb6,0x00,0x00},
+[183] = {0xb7,0x2a,0x2a},
+[184] = {0xb8,0x00,0x00},
+[185] = {0xb9,0x20,0x20},
+[186] = {0xba,0x00,0x00},
+[187] = {0xbb,0x00,0x00},
+[188] = {0xbc,0x00,0x00},
+[189] = {0xbd,0x00,0x00},
+[190] = {0xbe,0x00,0x00},
+[191] = {0xbf,0x00,0x00},
+[192] = {0xc0,0x00,0x00},
+[193] = {0xc1,0x00,0x00},
+[194] = {0xc2,0x00,0x00},
+[195] = {0xc3,0x00,0x00},
+[196] = {0xc4,0x00,0x00},
+[197] = {0xc5,0x00,0x00},
+[198] = {0xc6,0x00,0x00},
+[199] = {0xc7,0x00,0x00},
+[200] = {0xc8,0x00,0x00},
+[201] = {0xc9,0x00,0x00},
+[202] = {0xca,0x2d,0x5f},
+[203] = {0xcb,0x00,0x00},
+[204] = {0xcc,0x00,0x00},
+[205] = {0xcd,0x00,0x00},
+[206] = {0xce,0x2b,0x2b},
+[207] = {0xcf,0x00,0x00},
+[208] = {0xd0,0x00,0x00},
+[209] = {0xd1,0x00,0x00},
+[210] = {0xd2,0x00,0x00},
+[211] = {0xd3,0x00,0x00},
+[212] = {0xd4,0x00,0x00},
+[213] = {0xd5,0x00,0x00},
+[214] = {0xd6,0x00,0x00},
+[215] = {0xd7,0x00,0x00},
+[216] = {0xd8,0x00,0x00},
+[217] = {0xd9,0x00,0x00},
+[218] = {0xda,0x00,0x00},
+[219] = {0xdb,0x00,0x00},
+[220] = {0xdc,0x00,0x00},
+[221] = {0xdd,0x00,0x00},
+[222] = {0xde,0x00,0x00},
+[223] = {0xdf,0x00,0x00},
+[224] = {0xe0,0x00,0x00},
+[225] = {0xe1,0x00,0x00},
+[226] = {0xe2,0x00,0x00},
+[227] = {0xe3,0x00,0x00},
+[228] = {0xe4,0x00,0x00},
+[229] = {0xe5,0x00,0x00},
+[230] = {0xe6,0x00,0x00},
+[231] = {0xe7,0x00,0x00},
+[232] = {0xe8,0x00,0x00},
+[233] = {0xe9,0x00,0x00},
+[234] = {0xea,0x00,0x00},
+[235] = {0xeb,0x00,0x00},
+[236] = {0xec,0x00,0x00},
+[237] = {0xed,0x00,0x00},
+[238] = {0xee,0x00,0x00},
+[239] = {0xef,0x00,0x00},
+[240] = {0xf0,0x00,0x00},
+[241] = {0xf1,0x00,0x00},
+[242] = {0xf2,0x00,0x00},
+[243] = {0xf3,0x00,0x00},
+[244] = {0xf4,0x00,0x00},
+[245] = {0xf5,0x00,0x00},
+[246] = {0xf6,0x00,0x00},
+[247] = {0xf7,0x00,0x00},
+[248] = {0xf8,0x00,0x00},
+[249] = {0xf9,0x00,0x00},
+[250] = {0xfa,0x00,0x00},
+[251] = {0xfb,0x00,0x00},
+[252] = {0xfc,0x00,0x00},
+[253] = {0xfd,0x00,0x00},
+[254] = {0xfe,0x00,0x00},
+[255] = {0xff,0x00,0x00},
diff -urN linux-4.18-patched/drivers/input/keyboard/Makefile riscv-linux-riscv-linux-4.18/drivers/input/keyboard/Makefile
--- linux-4.18-patched/drivers/input/keyboard/Makefile	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/input/keyboard/Makefile	2018-09-16 10:04:11.495412555 +0100
@@ -67,3 +67,4 @@
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+obj-$(CONFIG_KEYBOARD_LOWRISC)		+= lowrisc-kbd.o lowrisc-fake-keys.o
diff -urN linux-4.18-patched/drivers/mmc/host/Kconfig riscv-linux-riscv-linux-4.18/drivers/mmc/host/Kconfig
--- linux-4.18-patched/drivers/mmc/host/Kconfig	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/mmc/host/Kconfig	2018-09-16 10:01:51.524156122 +0100
@@ -883,6 +883,12 @@
 
 	  If unsure, say N.
 
+config MMC_LOWRISC
+        tristate "LowRISC SD/MMC Card Interface Driver"
+        depends on RISCV
+        help
+          This selects the LowRISC SD-card driver based on Nexys4-DDR from Digilent
+
 config MMC_MTK
 	tristate "MediaTek SD/MMC Card Interface support"
 	depends on HAS_DMA
diff -urN linux-4.18-patched/drivers/mmc/host/lowrisc_sd.c riscv-linux-riscv-linux-4.18/drivers/mmc/host/lowrisc_sd.c
--- linux-4.18-patched/drivers/mmc/host/lowrisc_sd.c	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/mmc/host/lowrisc_sd.c	2018-08-18 10:23:34.203479000 +0100
@@ -0,0 +1,659 @@
+/*
+ *  LowRISC Secure Digital Host Controller Interface driver
+ *
+ *  Copyright (C) 2018 LowRISC CIC
+ *
+ *    Based on toshsd.c
+ *    Copyright (C) 2014 Ondrej Zary
+ *    Copyright (C) 2007 Richard Betts, All Rights Reserved.
+ *
+ *	Based on asic3_mmc.c, copyright (c) 2005 SDG Systems, LLC and,
+ *	sdhci.c, copyright (C) 2005-2006 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/platform_device.h>
+
+#include "lowrisc_sd.h"
+
+#define DRIVER_NAME "lowrisc-mmc"
+#define LOG(l) printk l
+#define LOGV(l) pr_debug l
+
+void sd_align(struct lowrisc_sd_host *host, int d_align)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[align_reg] = d_align;
+}
+
+void sd_clk_div(struct lowrisc_sd_host *host, int clk_div)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  /* This section is incomplete */
+  sd_base[clk_din_reg] = clk_div;
+}
+
+void sd_arg(struct lowrisc_sd_host *host, uint32_t arg)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[arg_reg] = arg;
+}
+
+void sd_cmd(struct lowrisc_sd_host *host, uint32_t cmd)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[cmd_reg] = cmd;
+}
+
+void sd_setting(struct lowrisc_sd_host *host, int setting)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[setting_reg] = setting;
+}
+
+void sd_cmd_start(struct lowrisc_sd_host *host, int sd_cmd)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[start_reg] = sd_cmd;
+}
+
+void sd_reset(struct lowrisc_sd_host *host, int sd_rst, int clk_rst, int data_rst, int cmd_rst)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[reset_reg] = ((sd_rst&1) << 3)|((clk_rst&1) << 2)|((data_rst&1) << 1)|((cmd_rst&1) << 0);
+}
+
+void sd_blkcnt(struct lowrisc_sd_host *host, int d_blkcnt)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[blkcnt_reg] = d_blkcnt&0xFFFF;
+}
+
+void sd_blksize(struct lowrisc_sd_host *host, int d_blksize)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[blksiz_reg] = d_blksize&0xFFF;
+}
+
+void sd_timeout(struct lowrisc_sd_host *host, int d_timeout)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[timeout_reg] = d_timeout;
+}
+
+void sd_irq_en(struct lowrisc_sd_host *host, int mask)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[irq_en_reg] = mask;
+  host->int_en = mask;
+  pr_debug("sd_irq_en(%X)\n", mask);
+}
+
+static void lowrisc_sd_init(struct lowrisc_sd_host *host)
+{
+
+}
+
+/* Set MMC clock / power */
+static void __lowrisc_sd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+	  mdelay(1);
+	  break;
+	case MMC_POWER_UP:
+	  break;
+	case MMC_POWER_ON:
+#if 0
+	  mdelay(20);
+#endif          
+	  break;
+	}
+
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_1:
+	  host->width_setting = 0;
+	  break;
+	case MMC_BUS_WIDTH_4:
+	  host->width_setting = 0x20;
+	  break;
+	}
+}
+
+static void lowrisc_sd_set_led(struct lowrisc_sd_host *host, unsigned char state)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[led_reg] = state;
+}
+
+static void lowrisc_sd_finish_request(struct lowrisc_sd_host *host)
+{
+	struct mmc_request *mrq = host->mrq;
+
+	/* Write something to end the command */
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+	sd_reset(host, 0,1,0,1);
+	sd_cmd_start(host, 0);
+	sd_reset(host, 0,1,1,1);
+	lowrisc_sd_set_led(host, 0);
+	mmc_request_done(host->mmc, mrq);
+}
+  
+static void lowrisc_sd_cmd_irq(struct lowrisc_sd_host *host)
+{
+	struct mmc_command *cmd = host->cmd;
+        volatile uint64_t *sd_base = host->ioaddr;
+
+	LOGV (("lowrisc_sd_cmd_irq\n"));
+	
+	if (!host->cmd) {
+		dev_warn(&host->pdev->dev, "Spurious CMD irq\n");
+		return;
+	}
+	host->cmd = NULL;
+
+        LOGV (("lowrisc_sd_cmd_irq IRQ line %d\n", __LINE__));
+	if (cmd->flags & MMC_RSP_PRESENT && cmd->flags & MMC_RSP_136) {
+	  int i;
+	  LOGV (("lowrisc_sd_cmd_irq IRQ line %d\n", __LINE__));
+		/* R2 */
+	  for (i = 0;i < 4;i++)
+	    {
+	    cmd->resp[i] = sd_base[resp0 + (3-i)] << 8;
+	    if (i != 3)
+	      cmd->resp[i] |= sd_base[resp0 + (2-i)] >> 24;
+	    } 
+	} else if (cmd->flags & MMC_RSP_PRESENT) {
+	  LOGV (("lowrisc_sd_cmd_irq IRQ line %d\n", __LINE__));
+		/* R1, R1B, R3, R6, R7 */
+	  cmd->resp[0] = sd_base[resp0];
+	}
+
+LOGV (("Command IRQ complete %d %d %x\n", cmd->opcode, cmd->error, cmd->flags));
+
+	/* If there is data to handle we will
+	 * finish the request in the mmc_data_end_irq handler.*/
+	if (host->data)
+	  {
+	    host->int_en |= SD_CARD_RW_END;
+	  }
+	else
+	  lowrisc_sd_finish_request(host);
+}
+
+static void lowrisc_sd_data_end_irq(struct lowrisc_sd_host *host)
+{
+	struct mmc_data *data = host->data;
+	unsigned long flags;
+	
+	LOGV (("lowrisc_sd_data_end_irq\n"));
+
+	host->data = NULL;
+
+	if (!data) {
+		dev_warn(&host->pdev->dev, "Spurious data end IRQ\n");
+		return;
+	}
+
+        if (data->flags & MMC_DATA_READ)
+	  {
+            volatile uint64_t *sd_base = 0x1000 + (volatile uint64_t *)(host->ioaddr);
+            int len;
+	    size_t blksize = data->blksz;
+
+	    local_irq_save(flags);
+
+            BUG_ON(!sg_miter_next(&host->sg_miter));
+            BUG_ON(host->sg_miter.length < blksize);
+	  	  
+	    if (!((sizeof(u64)-1) & (size_t)(host->sg_miter.addr))) // optimise case for aligned buffer
+	      {
+		u64 *buf = (u64 *)(host->sg_miter.addr);
+		for (len = blksize; len > 0; len -= sizeof(u64))
+		  {
+		  *buf++ = *sd_base++;
+		  }
+	      }
+	    else
+	      {
+		u8 *buf = host->sg_miter.addr;
+		for (len = blksize; len > 0; len -= sizeof(u64))
+		  {
+		  u64 scratch = *sd_base++;
+		  memcpy(buf, &scratch, sizeof(u64));
+		  buf += sizeof(u64);
+		  }
+	      }
+            host->sg_miter.consumed = blksize;
+	    sg_miter_stop(&host->sg_miter);
+
+	    local_irq_restore(flags);
+	  }
+
+	if (data->error == 0)
+		data->bytes_xfered = data->blocks * data->blksz;
+	else
+		data->bytes_xfered = 0;
+
+	LOGV (("Completed data request xfr=%d\n",
+	      data->bytes_xfered));
+
+        //	iowrite16(0, host->ioaddr + SD_STOPINTERNAL);
+
+	lowrisc_sd_finish_request(host);
+}
+
+static irqreturn_t lowrisc_sd_irq(int irq, void *dev_id)
+{
+	struct lowrisc_sd_host *host = dev_id;
+        volatile uint64_t *sd_base = host->ioaddr;
+	u32 int_reg, int_status;
+	int error = 0, ret = IRQ_HANDLED;
+
+	spin_lock(&host->lock);
+	int_status = sd_base[irq_stat_resp];
+	int_reg = int_status & host->int_en;
+
+	/* nothing to do: it's not our IRQ */
+	if (!int_reg) {
+		ret = IRQ_NONE;
+		goto irq_end;
+	}
+
+	LOGV (("lowrisc_sd IRQ status:%x enabled:%x\n", int_status, host->int_en));
+
+	if (sd_base[wait_resp] >= sd_base[timeout_resp]) {
+		error = -ETIMEDOUT;
+		LOGV (("lowrisc_sd timeout %lld clocks\n", sd_base[timeout_resp]));
+	} else if (int_reg & 0) {
+		error = -EILSEQ;
+		dev_err(&host->pdev->dev, "BadCRC\n");
+        }
+        
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+	if (error) {
+	  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+		if (host->cmd)
+			host->cmd->error = error;
+
+		if (error == -ETIMEDOUT) {
+		  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+                  sd_cmd_start(host, 0);
+                  sd_setting(host, 0);
+		} else {
+		  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+			lowrisc_sd_init(host);
+			__lowrisc_sd_set_ios(host->mmc, &host->mmc->ios);
+			goto irq_end;
+		}
+	}
+
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+        /* Card insert/remove. The mmc controlling code is stateless. */
+	if (int_reg & SD_CARD_CARD_REMOVED_0)
+	  {
+	    int mask = (host->int_en & ~SD_CARD_CARD_REMOVED_0) | SD_CARD_CARD_INSERTED_0;
+	    sd_irq_en(host, mask);
+	    printk("Card removed, mask changed to %d\n", mask);
+	    mmc_detect_change(host->mmc, 1);
+	  }
+	
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+	if (int_reg & SD_CARD_CARD_INSERTED_0)
+	  {
+	    int mask = (host->int_en & ~SD_CARD_CARD_INSERTED_0) | SD_CARD_CARD_REMOVED_0 ;
+	    sd_irq_en(host, mask);
+	    printk("Card inserted, mask changed to %d\n", mask);
+	    lowrisc_sd_init(host);
+	    mmc_detect_change(host->mmc, 1);
+	  }
+
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+	/* Command completion */
+	if (int_reg & SD_CARD_RESP_END) {
+	  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+		lowrisc_sd_cmd_irq(host);
+		host->int_en &= ~SD_CARD_RESP_END;
+	}
+
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+	/* Data transfer completion */
+	if (int_reg & SD_CARD_RW_END) {
+	  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+		lowrisc_sd_data_end_irq(host);
+		host->int_en &= ~SD_CARD_RW_END;
+	}
+irq_end:
+        sd_irq_en(host, host->int_en);
+	spin_unlock(&host->lock);
+	return ret;
+}
+
+static void lowrisc_sd_start_cmd(struct lowrisc_sd_host *host, struct mmc_command *cmd)
+{
+  int setting = 0;
+  int timeout = 1000000;
+  struct mmc_data *data = host->data;
+  volatile uint64_t *sd_base = host->ioaddr;
+  spin_lock(&host->lock);
+
+  LOGV (("Command opcode: %d\n", cmd->opcode));
+/*
+  if (cmd->opcode == MMC_STOP_TRANSMISSION) {
+    sd_cmd(host, SD_STOPINT_ISSUE_CMD12);
+
+    cmd->resp[0] = cmd->opcode;
+    cmd->resp[1] = 0;
+    cmd->resp[2] = 0;
+    cmd->resp[3] = 0;
+    
+    lowrisc_sd_finish_request(host);
+    return;
+  }
+*/
+  if (!(cmd->flags & MMC_RSP_PRESENT))
+    setting = 0;
+  else if (cmd->flags & MMC_RSP_136)
+    setting = 3;
+  else if (cmd->flags & MMC_RSP_BUSY)
+    setting = 1;
+  else
+    setting = 1;
+  setting |= host->width_setting;
+  
+  host->cmd = cmd;
+  
+  if (cmd->opcode == MMC_APP_CMD)
+    {
+      /* placeholder */
+    }
+  
+  if (cmd->opcode == MMC_GO_IDLE_STATE)
+    {
+      /* placeholder */
+    }
+
+  LOGV (("testing data flags\n"));
+  if (data) {
+    setting |= 0x4;
+    if (data->flags & MMC_DATA_READ)
+      setting |= 0x10;
+    else
+      {
+      setting |= 0x8;
+      }
+  }
+
+  LOGV (("writing registers\n"));
+  /* Send the command */
+  sd_reset(host, 0,1,0,1);
+  sd_align(host, 0);
+  sd_arg(host, cmd->arg);
+  sd_cmd(host, cmd->opcode);
+  sd_setting(host, setting);
+  sd_cmd_start(host, 0);
+  sd_reset(host, 0,1,1,1);
+  sd_timeout(host, timeout);
+  /* start the transaction */ 
+  sd_cmd_start(host, 1);
+  LOGV (("enabling interrupt\n"));
+  sd_irq_en(host, sd_base[irq_en_resp] | SD_CARD_RESP_END);
+spin_unlock(&host->lock);
+ LOGV (("leaving lowrisc_sd_start_cmd\n"));
+}
+
+static void lowrisc_sd_start_data(struct lowrisc_sd_host *host, struct mmc_data *data)
+{
+	unsigned int flags = SG_MITER_ATOMIC;
+
+	LOGV (("setup data transfer: blocksize %08x  nr_blocks %d, offset: %08x\n",
+	      data->blksz, data->blocks, data->sg->offset));
+
+	host->data = data;
+
+	if (data->flags & MMC_DATA_READ)
+		flags |= SG_MITER_TO_SG;
+	else
+		flags |= SG_MITER_FROM_SG;
+
+	sg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);
+
+	/* Set transfer length and blocksize */
+	sd_blkcnt(host, data->blocks);
+	sd_blksize(host, data->blksz);
+
+        if (!(data->flags & MMC_DATA_READ))
+	  {
+            volatile uint64_t *sd_base = 0x1000 + (volatile uint64_t *)(host->ioaddr);
+            struct mmc_data *data = host->data;
+            if (sg_miter_next(&host->sg_miter))
+              {
+                int len;
+                size_t blksize = data->blksz;
+                BUG_ON(host->sg_miter.length < blksize);
+		if (!((sizeof(u64)-1) & (size_t)(host->sg_miter.addr))) // optimise case for aligned buffer
+		  {
+		    u64 *buf = (u64 *)(host->sg_miter.addr);
+		    for (len = blksize; len > 0; len -= sizeof(u64))
+		      {
+			*sd_base++ = *buf++;
+		      }
+		  }
+		else
+		  {
+		    u8 *buf = host->sg_miter.addr;
+		    for (len = blksize; len > 0; len -= sizeof(u64))
+		      {
+			u64 scratch;
+			memcpy(&scratch, buf, sizeof(u64));
+			buf += sizeof(u64);
+			*sd_base++ = scratch;
+		      }
+		  }
+                host->sg_miter.consumed = blksize;
+                sg_miter_stop(&host->sg_miter);
+              }
+          }
+}
+
+/* Process requests from the MMC layer */
+static void lowrisc_sd_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+	unsigned long flags;
+
+	/* abort if card not present */
+	if (sd_base[detect_resp]) {
+		mrq->cmd->error = -ENOMEDIUM;
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	WARN_ON(host->mrq != NULL);
+
+	host->mrq = mrq;
+
+	if (mrq->data)
+		lowrisc_sd_start_data(host, mrq->data);
+
+	lowrisc_sd_set_led(host, 1);
+
+	lowrisc_sd_start_cmd(host, mrq->cmd);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void lowrisc_sd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	__lowrisc_sd_set_ios(mmc, ios);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static int lowrisc_sd_get_ro(struct mmc_host *mmc)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+	return sd_base[detect_resp];
+}
+
+static int lowrisc_sd_get_cd(struct mmc_host *mmc)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+
+	return !sd_base[detect_resp];
+}
+
+static int lowrisc_sd_card_busy(struct mmc_host *mmc)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+	return sd_base[resp0] >> 31;
+}
+
+static struct mmc_host_ops lowrisc_sd_ops = {
+	.request = lowrisc_sd_request,
+	.set_ios = lowrisc_sd_set_ios,
+	.get_ro = lowrisc_sd_get_ro,
+	.get_cd = lowrisc_sd_get_cd,
+	.card_busy = lowrisc_sd_card_busy,
+};
+
+
+static void lowrisc_sd_powerdown(struct lowrisc_sd_host *host)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  /* mask all interrupts */
+  sd_base[irq_en_reg] = 0;
+  /* disable card clock */
+}
+
+static int lowrisc_sd_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct lowrisc_sd_host *host;
+	struct mmc_host *mmc;
+        struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mmc = mmc_alloc_host(sizeof(struct lowrisc_sd_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+
+	host->pdev = pdev;
+
+	if (!request_mem_region(iomem->start, resource_size(iomem),
+		mmc_hostname(host->mmc))) {
+		dev_err(&pdev->dev, "cannot request region\n");
+		ret = -EBUSY;
+		goto release;
+	}
+
+	host->ioaddr = ioremap(iomem->start, resource_size(iomem));
+	if (!host->ioaddr) {
+		ret = -ENOMEM;
+		goto release;
+	}
+	printk("lowrisc-digilent-sd: Lowrisc sd platform driver (%llX-%llX) mapped to %lx\n",
+               iomem[0].start,
+               iomem[0].end,
+               (size_t)(host->ioaddr));
+        
+        host->irq = platform_get_irq(pdev, 0);
+        
+	/* Set MMC host parameters */
+	mmc->ops = &lowrisc_sd_ops;
+	mmc->caps = MMC_CAP_4_BIT_DATA;
+	mmc->ocr_avail = MMC_VDD_32_33;
+
+	mmc->f_min = 5000000;
+	mmc->f_max = 5000000;
+	mmc->max_blk_count = 1;
+	
+	spin_lock_init(&host->lock);
+
+	lowrisc_sd_init(host);
+
+	ret = request_irq(host->irq, lowrisc_sd_irq, IRQF_SHARED, DRIVER_NAME, host);
+        
+	if (ret)
+          {
+            printk("request_irq failed\n");
+            goto unmap;
+          }
+
+	mmc_add_host(mmc);
+
+	printk("lowrisc-sd driver loaded, IRQ %d\n", host->irq);
+	sd_irq_en(host, SD_CARD_CARD_INSERTED_0 | SD_CARD_CARD_REMOVED_0); /* get an interrupt either way */
+	return 0;
+
+unmap:
+release:
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int lowrisc_sd_remove(struct platform_device *pdev)
+{
+	struct lowrisc_sd_host *host = platform_get_drvdata(pdev);
+
+	mmc_remove_host(host->mmc);
+	lowrisc_sd_powerdown(host);
+	free_irq(host->irq, host);
+	mmc_free_host(host->mmc);
+        return 0;
+}
+
+static const struct of_device_id lowrisc_sd_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, lowrisc_sd_of_match);
+
+static struct platform_driver lowrisc_sd_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_sd_of_match,
+	},
+	.probe = lowrisc_sd_probe,
+	.remove = lowrisc_sd_remove,
+};
+
+module_platform_driver(lowrisc_sd_driver);
+
+MODULE_AUTHOR("Jonathan Kimmitt");
+MODULE_DESCRIPTION("LowRISC Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL");
diff -urN linux-4.18-patched/drivers/mmc/host/lowrisc_sd.h riscv-linux-riscv-linux-4.18/drivers/mmc/host/lowrisc_sd.h
--- linux-4.18-patched/drivers/mmc/host/lowrisc_sd.h	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/mmc/host/lowrisc_sd.h	2018-08-18 10:23:34.203479000 +0100
@@ -0,0 +1,49 @@
+/*
+ *  LowRISC PCI Secure Digital Host Controller Interface driver
+ *
+ *  Based on toshsd.h
+ *
+ *  Copyright (C) 2014 Ondrej Zary
+ *  Copyright (C) 2007 Richard Betts, All Rights Reserved.
+ *
+ *      Based on asic3_mmc.c Copyright (c) 2005 SDG Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+enum {align_reg,clk_din_reg,arg_reg,cmd_reg,
+      setting_reg,start_reg,reset_reg,blkcnt_reg,
+      blksiz_reg,timeout_reg,clk_pll_reg,irq_en_reg,
+      unused1,unused2,unused3,led_reg};
+
+enum {resp0,resp1,resp2,resp3,
+      wait_resp,status_resp,packet_resp0,packet_resp1,
+      data_wait_resp,trans_cnt_resp,obsolete1,obsolet2,
+      detect_resp,xfr_addr_resp,irq_stat_resp,pll_resp,
+      align_resp,clk_din_resp,arg_resp,cmd_i_resp,
+      setting_resp,start_resp,reset_resp,blkcnt_resp,
+      blksize_resp,timeout_resp,clk_pll_resp,irq_en_resp};
+
+enum {SD_APP_OP_COND=41, data_buffer_offset=0x2000};
+
+enum {SD_CARD_RESP_END=1,SD_CARD_RW_END=2, SD_CARD_CARD_REMOVED_0=4, SD_CARD_CARD_INSERTED_0=8};
+
+struct lowrisc_sd_host {
+  struct platform_device *pdev;
+  struct mmc_host *mmc;
+
+  spinlock_t lock;
+
+  struct mmc_request *mrq;/* Current request */
+  struct mmc_command *cmd;/* Current command */
+  struct mmc_data *data;	/* Current data request */
+
+  struct sg_mapping_iter sg_miter; /* for PIO */
+
+  void __iomem *ioaddr; /* mapped address */
+  int irq;
+  int int_en, width_setting;
+};
diff -urN linux-4.18-patched/drivers/mmc/host/Makefile riscv-linux-riscv-linux-4.18/drivers/mmc/host/Makefile
--- linux-4.18-patched/drivers/mmc/host/Makefile	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/mmc/host/Makefile	2018-09-16 10:02:00.451853428 +0100
@@ -68,6 +68,7 @@
 obj-$(CONFIG_MMC_USDHI6ROL0)	+= usdhi6rol0.o
 obj-$(CONFIG_MMC_TOSHIBA_PCI)	+= toshsd.o
 obj-$(CONFIG_MMC_BCM2835)	+= bcm2835.o
+obj-$(CONFIG_MMC_LOWRISC)       += lowrisc_sd.o
 
 obj-$(CONFIG_MMC_REALTEK_PCI)	+= rtsx_pci_sdmmc.o
 obj-$(CONFIG_MMC_REALTEK_USB)	+= rtsx_usb_sdmmc.o
diff -urN linux-4.18-patched/drivers/net/ethernet/Kconfig riscv-linux-riscv-linux-4.18/drivers/net/ethernet/Kconfig
--- linux-4.18-patched/drivers/net/ethernet/Kconfig	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/net/ethernet/Kconfig	2018-09-16 09:57:26.737145182 +0100
@@ -81,6 +81,7 @@
 source "drivers/net/ethernet/i825xx/Kconfig"
 source "drivers/net/ethernet/ibm/Kconfig"
 source "drivers/net/ethernet/intel/Kconfig"
+source "drivers/net/ethernet/lowrisc/Kconfig"
 source "drivers/net/ethernet/neterion/Kconfig"
 source "drivers/net/ethernet/xscale/Kconfig"
 
diff -urN linux-4.18-patched/drivers/net/ethernet/lowrisc/Kconfig riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/Kconfig
--- linux-4.18-patched/drivers/net/ethernet/lowrisc/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/Kconfig	2018-08-18 10:23:34.419471000 +0100
@@ -0,0 +1,26 @@
+#
+# Xilink device configuration
+#
+
+config NET_VENDOR_LOWRISC
+	bool "Lowrisc devices"
+	default y
+	depends on RISCV
+	---help---
+	  If you have a network (Ethernet) card belonging to this class, say Y.
+
+	  Note that the answer to this question doesn't directly affect the
+	  kernel: saying N will just cause the configurator to skip all
+	  the questions about Lowrisc devices. If you say Y, you will be asked
+	  for your specific card in the following questions.
+
+if NET_VENDOR_LOWRISC
+
+config LOWRISC_DIGILENT_100MHZ
+	tristate "Lowrisc 100MHz Ethernet Nexys4_DDR support"
+	depends on RISCV
+	select PHYLIB
+	---help---
+	  This driver supports the 100MHz Ethernet for Nexys4_DDR Digilent boards from Lowrisc.
+
+endif # NET_VENDOR_LOWRISC
diff -urN linux-4.18-patched/drivers/net/ethernet/lowrisc/lowrisc_100MHz.c riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/lowrisc_100MHz.c
--- linux-4.18-patched/drivers/net/ethernet/lowrisc/lowrisc_100MHz.c	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/lowrisc_100MHz.c	2018-09-16 10:00:23.651136666 +0100
@@ -0,0 +1,800 @@
+/*
+ * Lowrisc Ether100MHz Linux driver for the Lowrisc Ethernet 100MHz device.
+ *
+ * This is an experimental driver which is based on the original emac_lite
+ * driver from John Williams <john.williams@xilinx.com>.
+ *
+ * 2007 - 2013 (c) Xilinx, Inc.
+ * PHY control portions copyright (C) 2015 Microchip Technology
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mdio-bitbang.h>
+#include <linux/mdio-gpio.h>
+#include "lowrisc_100MHz.h"
+
+#define DRIVER_AUTHOR	"WOOJUNG HUH <woojung.huh@microchip.com>"
+#define DRIVER_DESC	"Microchip LAN8720 PHY driver"
+#define DRIVER_NAME     "lowrisc-eth"
+
+/* General Ethernet Definitions */
+#define XEL_ARP_PACKET_SIZE		28	/* Max ARP packet size */
+#define XEL_HEADER_IP_LENGTH_OFFSET	16	/* IP Length Offset */
+
+#define TX_TIMEOUT		(60*HZ)		/* Tx timeout is 60 seconds. */
+
+/**
+ * struct net_local - Our private per device data
+ * @ndev:		instance of the network device
+ * @reset_lock:		lock used for synchronization
+ * @phy_dev:		pointer to the PHY device
+ * @phy_node:		pointer to the PHY device node
+ * @mii_bus:		pointer to the MII bus
+ * @last_link:		last link status
+ */
+struct net_local {
+  struct mdiobb_ctrl ctrl; /* must be first for bitbang driver to work */
+  void __iomem *ioaddr;
+  struct net_device *ndev;
+  u32 msg_enable;
+  
+  struct phy_device *phy_dev;
+  struct mii_bus *mii_bus;
+  int last_duplex;
+  int last_carrier;
+  
+  /* Spinlock */
+  spinlock_t lock;
+  uint32_t last_mdio_gpio;
+  int irq;
+
+  struct napi_struct napi;
+};
+
+static void inline eth_write(struct net_local *priv, size_t addr, int data)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  eth_base[addr >> 3] = data;
+}
+
+static void inline eth_copyout(struct net_local *priv, uint8_t *data, int len)
+{
+  int i, rnd = ((len-1)|7)+1;
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  if (!(((size_t)data) & 7))
+    {
+      uint64_t *ptr = (uint64_t *)data;
+      for (i = 0; i < rnd/8; i++)
+        eth_base[TXBUFF_OFFSET/8 + i] = ptr[i];
+    }
+  else // We can't unfortunately rely on the skb being word aligned
+    {
+      uint64_t notptr;
+      for (i = 0; i < rnd/8; i++)
+        {
+          memcpy(&notptr, data+(i<<3), sizeof(uint64_t));
+          eth_base[TXBUFF_OFFSET/8 + i] = notptr;
+        }
+    }
+}
+
+static volatile inline int eth_read(struct net_local *priv, size_t addr)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  return eth_base[addr >> 3];
+}
+
+static inline void eth_copyin(struct net_local *priv, uint8_t *data, int len, int start)
+{
+  int i, rnd = ((len-1)|7)+1;
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  if (!(((size_t)data) & 7))
+    {
+      uint64_t *ptr = (uint64_t *)data;
+      for (i = 0; i < rnd/8; i++)
+        ptr[i] = eth_base[start + i];
+    }
+  else // We can't unfortunately rely on the skb being word aligned
+    {
+      for (i = 0; i < rnd/8; i++)
+        {
+          uint64_t notptr = eth_base[start + i];
+          memcpy(data+(i<<3), &notptr, sizeof(uint64_t));
+        }
+    }
+}
+
+static void inline eth_enable_irq(struct net_local *priv)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  eth_base[MACHI_OFFSET >> 3] |= MACHI_IRQ_EN;
+  mmiowb();
+}
+
+static void inline eth_disable_irq(struct net_local *priv)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  eth_base[MACHI_OFFSET >> 3] &= ~MACHI_IRQ_EN;
+  mmiowb();
+}
+
+/**
+ * lowrisc_update_address - Update the MAC address in the device
+ * @drvdata:	Pointer to the Ether100MHz device private data
+ * @address_ptr:Pointer to the MAC address (MAC address is a 48-bit value)
+ *
+ * Tx must be idle and Rx should be idle for deterministic results.
+ * It is recommended that this function should be called after the
+ * initialization and before transmission of any packets from the device.
+ * The MAC address can be programmed using any of the two transmit
+ * buffers (if configured).
+ */
+
+static void lowrisc_update_address(struct net_local *priv, u8 *address_ptr)
+{
+  uint32_t macaddr_lo, macaddr_hi;
+  uint32_t flags = 0;
+  memcpy (&macaddr_lo, address_ptr+2, sizeof(uint32_t));
+  memcpy (&macaddr_hi, address_ptr+0, sizeof(uint16_t));
+  eth_write(priv, MACLO_OFFSET, htonl(macaddr_lo));
+  eth_write(priv, MACHI_OFFSET, flags|htons(macaddr_hi));
+}
+
+/**
+ * lowrisc_read_mac_address - Read the MAC address in the device
+ * @drvdata:	Pointer to the Ether100MHz device private data
+ * @address_ptr:Pointer to the 6-byte buffer to receive the MAC address (MAC address is a 48-bit value)
+ *
+ * In lowrisc the starting value is programmed by the boot loader according to DIP switch [15:12]
+ */
+
+static void lowrisc_read_mac_address(struct net_local *priv, u8 *address_ptr)
+{
+  uint32_t macaddr_hi = ntohs(eth_read(priv, MACHI_OFFSET)&MACHI_MACADDR_MASK);
+  uint32_t macaddr_lo = ntohl(eth_read(priv, MACLO_OFFSET));
+  memcpy (address_ptr+2, &macaddr_lo, sizeof(uint32_t));
+  memcpy (address_ptr+0, &macaddr_hi, sizeof(uint16_t));
+}
+
+/**
+ * lowrisc_set_mac_address - Set the MAC address for this device
+ * @dev:	Pointer to the network device instance
+ * @addr:	Void pointer to the sockaddr structure
+ *
+ * This function copies the HW address from the sockaddr strucutre to the
+ * net_device structure and updates the address in HW.
+ *
+ * Return:	Error if the net device is busy or 0 if the addr is set
+ *		successfully
+ */
+static int lowrisc_set_mac_address(struct net_device *ndev, void *address)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	struct sockaddr *addr = address;
+	memcpy(ndev->dev_addr, addr->sa_data, ndev->addr_len);
+	lowrisc_update_address(priv, ndev->dev_addr);
+	return 0;
+}
+
+/**
+ * lowrisc_tx_timeout - Callback for Tx Timeout
+ * @dev:	Pointer to the network device
+ *
+ * This function is called when Tx time out occurs for Ether100MHz device.
+ */
+static void lowrisc_tx_timeout(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+
+	dev_err(&priv->ndev->dev, "Exceeded transmit timeout of %lu ms\n",
+		TX_TIMEOUT * 1000UL / HZ);
+
+	ndev->stats.tx_errors++;
+
+	/* Reset the device */
+	spin_lock(&priv->lock);
+
+	/* Shouldn't really be necessary, but shouldn't hurt */
+	netif_stop_queue(ndev);
+
+	/* To exclude tx timeout */
+        netif_trans_update(ndev); /* prevent tx timeout */
+
+	/* We're all ready to go. Start the queue */
+	netif_wake_queue(ndev);
+	spin_unlock(&priv->lock);
+}
+
+/**
+ * lowrisc_close - Close the network device
+ * @dev:	Pointer to the network device
+ *
+ * This function stops the Tx queue, disables interrupts and frees the IRQ for
+ * the Ether100MHz device.
+ * It also disconnects the phy device associated with the Ether100MHz device.
+ */
+static int lowrisc_close(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+        napi_disable(&priv->napi);
+	eth_disable_irq(priv);
+	free_irq(priv->irq, ndev);
+        printk("Close device, free interrupt\n");
+        
+	if (priv->phy_dev)
+		phy_disconnect(priv->phy_dev);
+	priv->phy_dev = NULL;
+
+	return 0;
+}
+
+/**
+ * lowrisc_remove_ndev - Free the network device
+ * @ndev:	Pointer to the network device to be freed
+ *
+ * This function un maps the IO region of the Ether100MHz device and frees the net
+ * device.
+ */
+static void lowrisc_remove_ndev(struct net_device *ndev)
+{
+	if (ndev) {
+		free_netdev(ndev);
+	}
+}
+
+static void lowrisc_phy_adjust_link(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	struct phy_device *phy_dev = priv->phy_dev;
+	int carrier;
+
+	if (phy_dev->duplex != priv->last_duplex) {
+		if (phy_dev->duplex) {
+			netif_dbg(priv, link, priv->ndev, "full duplex mode\n");
+		} else {
+			netif_dbg(priv, link, priv->ndev, "half duplex mode\n");
+		}
+
+		priv->last_duplex = phy_dev->duplex;
+	}
+
+	carrier = netif_carrier_ok(ndev);
+	if (carrier != priv->last_carrier) {
+		if (carrier)
+			netif_dbg(priv, link, priv->ndev, "carrier OK\n");
+		else
+			netif_dbg(priv, link, priv->ndev, "no carrier\n");
+		priv->last_carrier = carrier;
+	}
+}
+
+static int lowrisc_mii_probe(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	struct phy_device *phydev = NULL;
+	const char *phyname;
+	
+	BUG_ON(priv->phy_dev);
+
+	/* Device only supports internal PHY at address 1 */
+	phydev = mdiobus_get_phy(priv->mii_bus, 1);
+	if (!phydev) {
+		netdev_err(ndev, "no PHY found at address 1\n");
+		return -ENODEV;
+	}
+
+	phyname = phydev_name(phydev);
+	printk("Probing %s\n", phyname);
+	
+	phydev = phy_connect(ndev, phyname,
+			     lowrisc_phy_adjust_link, PHY_INTERFACE_MODE_MII);
+
+	if (IS_ERR(phydev)) {
+		netdev_err(ndev, "Could not attach to PHY\n");
+		return PTR_ERR(phydev);
+	}
+
+	/* mask with MAC supported features */
+	phydev->supported &= (PHY_BASIC_FEATURES | SUPPORTED_Pause |
+			      SUPPORTED_Asym_Pause);
+	phydev->advertising = phydev->supported;
+
+	phy_attached_info(phydev);
+
+	priv->phy_dev = phydev;
+	priv->last_duplex = -1;
+	priv->last_carrier = -1;
+
+	return 0;
+}
+
+static void mdio_dir(struct mdiobb_ctrl *ctrl, int dir)
+{
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  if (dir)
+    priv->last_mdio_gpio &= ~MDIOCTRL_MDIOOEN_MASK; // output driving
+  else
+    priv->last_mdio_gpio |= MDIOCTRL_MDIOOEN_MASK; // input receiving
+    
+  eth_write(priv, MDIOCTRL_OFFSET, priv->last_mdio_gpio);
+}
+
+static int mdio_get(struct mdiobb_ctrl *ctrl)
+{
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  uint32_t rslt = eth_read(priv, MDIOCTRL_OFFSET) & MDIOCTRL_MDIOIN_MASK ? 1:0;
+  return rslt;
+}
+
+static void mdio_set(struct mdiobb_ctrl *ctrl, int what)
+{
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  if (what)
+    priv->last_mdio_gpio |= MDIOCTRL_MDIOOUT_MASK;
+  else
+    priv->last_mdio_gpio &= ~MDIOCTRL_MDIOOUT_MASK;
+    
+  eth_write(priv, MDIOCTRL_OFFSET, priv->last_mdio_gpio);
+}
+
+static void mdc_set(struct mdiobb_ctrl *ctrl, int what)
+{
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  if (what)
+    priv->last_mdio_gpio |= MDIOCTRL_MDIOCLK_MASK;
+  else
+    priv->last_mdio_gpio &= ~MDIOCTRL_MDIOCLK_MASK;
+    
+  eth_write(priv, MDIOCTRL_OFFSET, priv->last_mdio_gpio);
+}
+
+#ifdef MDIO_RESET
+/* reset callback */
+static int mdio_reset(struct mii_bus *bus)
+{
+  struct net_local *priv = (struct net_local *)bus->priv;
+  eth_write(priv, MDIOCTRL_OFFSET, MDIOCTRL_MDIORST_MASK);
+  mdelay(100);
+  eth_write(priv, MDIOCTRL_OFFSET, 0);
+  mdelay(100);
+  return 0;
+}
+#endif
+
+static struct mdiobb_ops mdio_gpio_ops = {
+        .owner = THIS_MODULE,
+        .set_mdc = mdc_set,
+        .set_mdio_dir = mdio_dir,
+        .set_mdio_data = mdio_set,
+        .get_mdio_data = mdio_get,
+};
+
+static int lowrisc_mii_init(struct net_device *ndev)
+{
+        struct mii_bus *new_bus;
+	struct net_local *priv = netdev_priv(ndev);
+	int err = -ENXIO;
+	
+	priv->ctrl.ops = &mdio_gpio_ops;
+#ifdef MDIO_RESET
+	priv->ctrl.reset = mdio_reset;
+#endif
+        new_bus = alloc_mdio_bitbang(&(priv->ctrl));
+
+	if (!new_bus) {
+		err = -ENOMEM;
+		goto err_out_1;
+	}
+	snprintf(new_bus->id, MII_BUS_ID_SIZE, "lowrisc-0");
+        new_bus->name = "GPIO Bitbanged LowRISC",
+
+        new_bus->phy_mask = ~(1 << 1);
+        new_bus->phy_ignore_ta_mask = 0;
+
+	mutex_init(&(new_bus->mdio_lock));
+	
+	priv->mii_bus = new_bus;
+	priv->mii_bus->priv = priv;
+
+	/* Mask all PHYs except ID 1 (internal) */
+	priv->mii_bus->phy_mask = ~(1 << 1);
+
+	if (mdiobus_register(priv->mii_bus)) {
+		netif_warn(priv, probe, priv->ndev, "Error registering mii bus\n");
+		goto err_out_free_bus_2;
+	}
+
+	if (lowrisc_mii_probe(ndev) < 0) {
+		netif_warn(priv, probe, priv->ndev, "Error probing mii bus\n");
+		goto err_out_unregister_bus_3;
+	}
+
+	return 0;
+
+err_out_unregister_bus_3:
+	mdiobus_unregister(priv->mii_bus);
+err_out_free_bus_2:
+	mdiobus_free(priv->mii_bus);
+err_out_1:
+	return err;
+}
+/**********************/
+/* Interrupt Handlers */
+/**********************/
+
+/**
+ * lowrisc_ether_isr - Interrupt handler for frames received
+ * @dev:	Pointer to the network device
+ *
+ * This function allocates memory for a socket buffer, fills it with data
+ * received and hands it over to the TCP/IP stack.
+ */
+
+static int lowrisc_ether_poll(struct napi_struct *napi, int budget)
+{
+  int rsr, buf, rx_count = 0;
+  struct net_local *priv = container_of(napi, struct net_local, napi);
+  struct net_device *ndev = priv->ndev;
+  rsr = eth_read(priv, RSR_OFFSET);
+  buf = rsr & RSR_RECV_FIRST_MASK;
+  /* Check if there is Rx Data available */
+  while ((rsr & RSR_RECV_DONE_MASK) && (rx_count < budget))
+    {
+      int rplr = eth_read(priv, RPLR_OFFSET+((buf&7)<<3));
+      int errs = eth_read(priv, RBAD_OFFSET);
+      int len = (rplr & RPLR_LENGTH_MASK) - 4; /* discard FCS bytes */
+      if ((len >= 14) && ((0x101<<(buf&7)) & ~errs) && (len <= ETH_FRAME_LEN + ETH_FCS_LEN))
+	{
+	  int rnd = ((len-1)|7)+1; /* round to a multiple of 8 */
+	  struct sk_buff *skb = __napi_alloc_skb(napi, rnd, GFP_ATOMIC|__GFP_NOWARN); // Don't warn, just drop surplus packets
+	  if (unlikely(!skb))
+	    {
+	      /* Couldn't get memory, we carry on regardless and drop if necessary */
+	      ndev->stats.rx_dropped++;
+	    }
+	  else
+	    {
+	      int start = RXBUFF_OFFSET/8 + ((buf&7)<<8);
+              skb_put(skb, len);	/* Tell the skb how much data we got */
+	      
+              eth_copyin(priv, skb->data, len, start);
+              skb->protocol = eth_type_trans(skb, ndev);
+              netif_receive_skb(skb);
+              ndev->stats.rx_packets++;
+              ndev->stats.rx_bytes += len;
+              ++rx_count;
+            }
+        }
+      else
+	  ndev->stats.rx_errors++;
+      /* acknowledge, even if an error occurs, to reset irq */
+      eth_write(priv, RSR_OFFSET, ++buf);
+      rsr = eth_read(priv, RSR_OFFSET);
+    }
+
+  if (rx_count < budget)
+    {
+      napi_complete_done(napi, rx_count);
+      eth_enable_irq(priv);
+    }
+    
+  return rx_count;
+}
+
+irqreturn_t lowrisc_ether_isr(int irq, void *dev_id)
+{
+  int rsr;
+  irqreturn_t rc = IRQ_NONE;
+  struct net_device *ndev = dev_id;
+  struct net_local *priv = netdev_priv(ndev);
+  rsr = eth_read(priv, RSR_OFFSET);
+  /* Check if there is Rx Data available */
+  if (rsr & RSR_RECV_DONE_MASK)
+    {
+      if (napi_schedule_prep(&priv->napi))
+        {
+          eth_disable_irq(priv);
+          __napi_schedule(&priv->napi);
+          rc = IRQ_HANDLED;
+        }
+    }
+  return rc;
+}
+
+static int lowrisc_get_regs_len(struct net_device __always_unused *netdev)
+{
+#define LOWRISC_REGS_LEN 40	/* overestimate */
+  return LOWRISC_REGS_LEN * sizeof(u32);
+}
+
+static void lowrisc_get_regs(struct net_device *ndev,
+			   struct ethtool_regs *regs, void *p)
+{
+  struct net_local *priv = netdev_priv(ndev);
+  struct phy_device *phy = priv->phy_dev;
+
+  u32 *regs_buff = p;
+  int i;
+
+  memset(p, 0, LOWRISC_REGS_LEN * sizeof(u32));
+
+  regs->version = 0;
+
+  for (i = 0; i < LOWRISC_REGS_LEN; i++)
+    {
+      if (i >= 32)
+	regs_buff[i] = eth_read(priv, MACLO_OFFSET+((i-32)<<3));
+      else
+	{
+	regs_buff[i] = phy_read(phy, i);
+	}
+    }
+}
+
+static const struct ethtool_ops lowrisc_ethtool_ops = {
+	.get_regs_len		= lowrisc_get_regs_len,
+	.get_regs		= lowrisc_get_regs
+};
+
+/**
+ * lowrisc_open - Open the network device
+ * @dev:	Pointer to the network device
+ *
+ * This function sets the MAC address, requests an IRQ and enables interrupts
+ * for the Ether100MHz device and starts the Tx queue.
+ * It also connects to the phy device, if MDIO is included in Ether100MHz device.
+ */
+
+static int lowrisc_open(struct net_device *ndev)
+{
+  int retval;
+  struct net_local *priv = netdev_priv(ndev);
+  ndev->ethtool_ops = &lowrisc_ethtool_ops;
+
+  /* Set the MAC address each time opened */
+  lowrisc_update_address(priv, ndev->dev_addr);
+  
+  if (priv->phy_dev) {
+    /* Ether100MHz doesn't support giga-bit speeds */
+    priv->phy_dev->supported &= (PHY_BASIC_FEATURES);
+    priv->phy_dev->advertising = priv->phy_dev->supported;
+    
+    phy_start(priv->phy_dev);
+  }
+  
+  /* Grab the IRQ */
+  printk("Open device, request interrupt %d\n", priv->irq);
+  retval = request_irq(priv->irq, lowrisc_ether_isr, IRQF_SHARED, ndev->name, ndev);
+  if (retval) {
+    dev_err(&priv->ndev->dev, "Could not allocate interrupt %d\n", priv->irq);
+    if (priv->phy_dev)
+      phy_disconnect(priv->phy_dev);
+    priv->phy_dev = NULL;
+    
+    return retval;
+  }
+  
+  lowrisc_update_address(priv, ndev->dev_addr);
+
+  /* We're ready to go */
+  napi_enable(&priv->napi);
+  netif_start_queue(ndev);
+
+  /* first call to handler enables the irq */
+  lowrisc_ether_isr(priv->irq, ndev);
+  return 0;
+}
+
+/**
+ * lowrisc_send - Transmit a frame
+ * @orig_skb:	Pointer to the socket buffer to be transmitted
+ * @dev:	Pointer to the network device
+ *
+ * This function checks if the Tx buffer of the Ether100MHz device is free to send
+ * data. If so, it fills the Tx buffer with data from socket buffer data,
+ * updates the stats and frees the socket buffer.
+ * Return:	0, always.
+ */
+static int lowrisc_send(struct sk_buff *new_skb, struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	unsigned int len = new_skb->len;
+        int rslt;
+	spin_lock(&priv->lock);
+        rslt = eth_read(priv, TPLR_OFFSET);
+        if (rslt & TPLR_BUSY_MASK)
+          printk("TX Busy Status = %x, len = %d, ignoring\n", rslt, len);
+        eth_copyout(priv, new_skb->data, len);
+        eth_write(priv, TPLR_OFFSET, len);
+	spin_unlock(&priv->lock);
+
+	skb_tx_timestamp(new_skb);
+
+	ndev->stats.tx_bytes += len;
+	ndev->stats.tx_packets++;
+	dev_consume_skb_any(new_skb);
+
+	return 0;
+}
+
+static int lowrisc_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+        struct net_local *priv = netdev_priv(netdev);
+	struct phy_device *phy = priv->phy_dev;
+        struct mii_ioctl_data *data = if_mii(ifr);
+
+        switch (cmd) {
+        case SIOCGMIIPHY:
+                data->phy_id = 1;
+                break;
+        case SIOCGMIIREG:
+                data->val_out = phy_read(phy, data->reg_num);
+                break;
+        case SIOCSMIIREG:
+                phy_write(phy, data->reg_num, data->val_in);
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+        return 0;
+	}
+
+static struct net_device_ops lowrisc_netdev_ops = {
+	.ndo_open		= lowrisc_open,
+	.ndo_stop		= lowrisc_close,
+	.ndo_start_xmit		= lowrisc_send,
+	.ndo_set_mac_address	= lowrisc_set_mac_address,
+	.ndo_tx_timeout		= lowrisc_tx_timeout,
+	.ndo_do_ioctl           = lowrisc_mii_ioctl,
+};
+
+/**
+ * lowrisc_of_probe - Probe method for the Ether100MHz device.
+ * @ofdev:	Pointer to OF device structure
+ * @match:	Pointer to the structure used for matching a device
+ *
+ * This function probes for the Ether100MHz device in the device tree.
+ * It initializes the driver data structure and the hardware, sets the MAC
+ * address and registers the network device.
+ * It also registers a mii_bus for the Ether100MHz device, if MDIO is included
+ * in the device.
+ *
+ * Return:	0, if the driver is bound to the Ether100MHz device, or
+ *		a negative error if there is failure.
+ */
+static int lowrisc_100MHz_probe(struct platform_device *ofdev)
+{
+	struct net_device *ndev = NULL;
+	struct net_local *priv = NULL;
+	struct device *dev = &ofdev->dev;
+        struct resource *lowrisc_ethernet;
+	unsigned char mac_address[7];
+	int rc = 0;
+
+        lowrisc_ethernet = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+
+	/* Create an ethernet device instance */
+	ndev = alloc_etherdev(sizeof(struct net_local));
+	if (!ndev)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, ndev);
+	SET_NETDEV_DEV(ndev, &ofdev->dev);
+        platform_set_drvdata(ofdev, ndev);
+        
+	priv = netdev_priv(ndev);
+	priv->ndev = ndev;
+        priv->ioaddr = devm_ioremap_resource(&ofdev->dev, lowrisc_ethernet);
+
+	ndev->netdev_ops = &lowrisc_netdev_ops;
+	ndev->flags &= ~IFF_MULTICAST;
+	ndev->watchdog_timeo = TX_TIMEOUT;
+        netif_napi_add(ndev, &priv->napi, lowrisc_ether_poll, 8);
+
+	printk("lowrisc-digilent-ethernet: Lowrisc ethernet platform (%llX-%llX) mapped to %lx\n",
+               lowrisc_ethernet[0].start,
+               lowrisc_ethernet[0].end,
+               (size_t)(priv->ioaddr));
+
+        priv->irq = platform_get_irq(ofdev, 0);
+        
+	spin_lock_init(&priv->lock);
+
+        /* get the MAC address set by the boot loader */
+        lowrisc_read_mac_address(priv, mac_address);
+	memcpy(ndev->dev_addr, mac_address, ETH_ALEN);
+
+	/* Set the MAC address in the Ether100MHz device */
+	lowrisc_update_address(priv, ndev->dev_addr);
+
+	lowrisc_mii_init(ndev);
+
+	/* Finally, register the device */
+	rc = register_netdev(ndev);
+	if (rc) {
+          dev_err(dev,
+                  "Cannot register network device, aborting\n");
+          goto error;
+	}
+
+	dev_info(dev, "Lowrisc Ether100MHz registered\n");
+	
+	return 0;
+
+error:
+	lowrisc_remove_ndev(ndev);
+	return rc;
+}
+
+/* Match table for OF platform binding */
+static const struct of_device_id lowrisc_100MHz_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, lowrisc_100MHz_of_match);
+
+void lowrisc_100MHz_free(struct platform_device *of_dev)
+{
+        struct resource *iomem = platform_get_resource(of_dev, IORESOURCE_MEM, 0);
+        release_mem_region(iomem->start, resource_size(iomem));
+}
+
+int lowrisc_100MHz_unregister(struct platform_device *of_dev)
+{
+        lowrisc_100MHz_free(of_dev);
+        return 0;
+}
+
+static struct platform_driver lowrisc_100MHz_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_100MHz_of_match,
+	},
+	.probe = lowrisc_100MHz_probe,
+	.remove = lowrisc_100MHz_unregister,
+};
+
+module_platform_driver(lowrisc_100MHz_driver);
+
+MODULE_AUTHOR("Jonathan Kimmitt");
+MODULE_DESCRIPTION("Lowrisc Ethernet 100MHz driver");
+MODULE_LICENSE("GPL");
diff -urN linux-4.18-patched/drivers/net/ethernet/lowrisc/lowrisc_100MHz.h riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/lowrisc_100MHz.h
--- linux-4.18-patched/drivers/net/ethernet/lowrisc/lowrisc_100MHz.h	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/lowrisc_100MHz.h	2018-08-18 10:23:34.419471000 +0100
@@ -0,0 +1,60 @@
+// See LICENSE for license details.
+
+#ifndef ETH_HEADER_H
+#define ETH_HEADER_H
+
+/* Register offsets for the LowRISC Ethernet Core */
+
+/* Register offsets (in bytes) for the LowRISC Core */
+#define TXBUFF_OFFSET       0x1000          /* Transmit Buffer */
+
+#define MACLO_OFFSET        0x0800          /* MAC address low 32-bits */
+#define MACHI_OFFSET        0x0808          /* MAC address high 16-bits and MAC ctrl */
+#define TPLR_OFFSET         0x0810          /* Tx packet length */
+#define TFCS_OFFSET         0x0818          /* Tx frame check sequence register */
+#define MDIOCTRL_OFFSET     0x0820          /* MDIO Control Register */
+#define RFCS_OFFSET         0x0828          /* Rx frame check sequence register(read) and last register(write) */
+#define RSR_OFFSET          0x0830          /* Rx status and reset register */
+#define RBAD_OFFSET         0x0838          /* Rx bad frame and bad fcs register arrays */
+#define RPLR_OFFSET         0x0840          /* Rx packet length register array */
+
+#define RXBUFF_OFFSET       0x4000          /* Receive Buffer */
+
+/* MAC Ctrl Register (MACHI) Bit Masks */
+#define MACHI_MACADDR_MASK    0x0000FFFF     /* MAC high 16-bits mask */
+#define MACHI_COOKED_MASK     0x00010000     /* obsolete flag */
+#define MACHI_LOOPBACK_MASK   0x00020000     /* Rx loopback packets */
+#define MACHI_ALLPKTS_MASK    0x00400000     /* Rx all packets (promiscuous mode) */
+#define MACHI_IRQ_EN          0x00800000     /* Rx packet interrupt enable */
+
+/* MDIO Control Register Bit Masks */
+#define MDIOCTRL_MDIOCLK_MASK 0x00000001    /* MDIO Clock Mask */
+#define MDIOCTRL_MDIOOUT_MASK 0x00000002    /* MDIO Output Mask */
+#define MDIOCTRL_MDIOOEN_MASK 0x00000004    /* MDIO Output Enable Mask, 3-state enable, high=input, low=output */
+#define MDIOCTRL_MDIORST_MASK 0x00000008    /* MDIO Input Mask */
+#define MDIOCTRL_MDIOIN_MASK  0x00000008    /* MDIO Input Mask */
+
+/* Transmit Status Register (TPLR) Bit Masks */
+#define TPLR_FRAME_ADDR_MASK  0x0FFF0000     /* Tx frame address */
+#define TPLR_PACKET_LEN_MASK  0x00000FFF     /* Tx packet length */
+#define TPLR_BUSY_MASK        0x80000000     /* Tx busy mask */
+
+/* Receive Status Register (RSR) */
+#define RSR_RECV_FIRST_MASK   0x0000000F      /* first available buffer (static) */
+#define RSR_RECV_NEXT_MASK    0x000000F0      /* current rx buffer (volatile) */
+#define RSR_RECV_LAST_MASK    0x00000F00      /* last available rx buffer (static) */
+#define RSR_RECV_DONE_MASK    0x00001000      /* Rx complete */
+#define RSR_RECV_IRQ_MASK     0x00002000      /* Rx irq bit */
+
+/* Receive Packet Length Register (RPLR) */
+#define RPLR_LENGTH_MASK      0x00000FFF      /* Rx packet length */
+#define RPLR_ERROR_MASK       0x40000000      /* Rx error mask */
+#define RPLR_FCS_ERROR_MASK   0x80000000      /* Rx FCS error mask */
+
+/* General Ethernet Definitions */
+#define HEADER_OFFSET               12      /* Offset to length field */
+#define HEADER_SHIFT                16      /* Shift value for length */
+#define ARP_PACKET_SIZE             28      /* Max ARP packet size */
+#define HEADER_IP_LENGTH_OFFSET     16      /* IP Length Offset */
+
+#endif
diff -urN linux-4.18-patched/drivers/net/ethernet/lowrisc/Makefile riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/Makefile
--- linux-4.18-patched/drivers/net/ethernet/lowrisc/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/net/ethernet/lowrisc/Makefile	2018-08-18 10:23:34.419471000 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for the Lowrisc network device driver.
+#
+
+obj-$(CONFIG_LOWRISC_DIGILENT_100MHZ) += lowrisc_100MHz.o
+CFLAGS_lowrisc_100MHz.o := -DDEBUG
diff -urN linux-4.18-patched/drivers/net/ethernet/Makefile riscv-linux-riscv-linux-4.18/drivers/net/ethernet/Makefile
--- linux-4.18-patched/drivers/net/ethernet/Makefile	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/net/ethernet/Makefile	2018-09-16 09:57:37.488779675 +0100
@@ -50,6 +50,7 @@
 obj-$(CONFIG_JME) += jme.o
 obj-$(CONFIG_KORINA) += korina.o
 obj-$(CONFIG_LANTIQ_ETOP) += lantiq_etop.o
+obj-$(CONFIG_NET_VENDOR_LOWRISC) += lowrisc/
 obj-$(CONFIG_NET_VENDOR_MARVELL) += marvell/
 obj-$(CONFIG_NET_VENDOR_MEDIATEK) += mediatek/
 obj-$(CONFIG_NET_VENDOR_MELLANOX) += mellanox/
diff -urN linux-4.18-patched/drivers/video/console/Kconfig riscv-linux-riscv-linux-4.18/drivers/video/console/Kconfig
--- linux-4.18-patched/drivers/video/console/Kconfig	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/video/console/Kconfig	2018-09-16 09:51:31.333190848 +0100
@@ -90,6 +90,11 @@
           Say Y here if you want the console on the Newport aka XL graphics
           card of your Indy.  Most people say Y here.
 
+config LOWRISC_VGA_CONSOLE
+	bool
+	depends on RISCV
+	default y
+
 config DUMMY_CONSOLE
 	bool
 	depends on VGA_CONSOLE!=y || SGI_NEWPORT_CONSOLE!=y 
diff -urN linux-4.18-patched/drivers/video/console/lowrisc-con.c riscv-linux-riscv-linux-4.18/drivers/video/console/lowrisc-con.c
--- linux-4.18-patched/drivers/video/console/lowrisc-con.c	1970-01-01 01:00:00.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/video/console/lowrisc-con.c	2018-08-25 19:54:52.000000000 +0100
@@ -0,0 +1,240 @@
+/*
+ *  linux/drivers/video/lowrisc_con.c -- A lowrisc console driver
+ *
+ *  Based on dummycon.c (for plain VGA text)
+ *
+ *  This lowrisc device is designed to replicate some of the functions of a PC VGA console
+ *  It does not have graphics, colour is rudimentary and scrolling primitive. Cursor control is TBD.
+ */
+
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/console.h>
+#include <linux/vt_kern.h>
+#include <linux/screen_info.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <asm/sbi.h>
+
+#define DRIVER_NAME     "lowrisc-vga"
+
+/*
+ *  Lowrisc console driver
+ */
+
+#define LOWRISC_MEM	4096
+#define LOWRISC_COLUMNS	128
+#define LOWRISC_ROWS	31
+
+static uint16_t *hid_vga_ptr;
+static int oldxpos, oldypos;
+
+static void mymove(uint16_t *dest, const uint16_t *src, size_t n)
+{
+  if (dest < hid_vga_ptr || dest+n > hid_vga_ptr+LOWRISC_MEM || src < hid_vga_ptr || src+n > hid_vga_ptr+LOWRISC_MEM)
+    printk("out of range scroll move %lx\n", (long)dest);
+  else
+    memmove(dest, src, n*sizeof(u16));
+}
+
+static void myset(uint16_t *dest, int c, size_t n)
+{
+  if (dest < hid_vga_ptr || dest+n > hid_vga_ptr+LOWRISC_MEM)
+    printk("out of range scroll set %lx\n", (long)dest);
+  else
+    memset(dest, c, n);
+}
+
+static const char *lowrisc_con_startup(void)
+{
+    return "lowrisc device";
+}
+
+static void lowrisc_con_init(struct vc_data *vc, int init)
+{
+    vc->vc_can_do_color = 1;
+    if (init) {
+	vc->vc_cols = LOWRISC_COLUMNS;
+	vc->vc_rows = LOWRISC_ROWS;
+    } else
+	vc_resize(vc, LOWRISC_COLUMNS, LOWRISC_ROWS);
+}
+
+static void lowrisc_con_deinit(struct vc_data *vc) { }
+
+static void lowrisc_con_clear(struct vc_data *vc, int sy, int sx, int height, int width)
+{
+}
+
+static void lowrisc_con_putc(struct vc_data *vc, int c, int ypos, int xpos)
+{
+  extern void lowrisc_shadow_console_putchar(int);
+  hid_vga_ptr[LOWRISC_COLUMNS*ypos+xpos] = c;
+#ifdef CONFIG_KEYBOARD_LOWRISC
+  if (xpos == oldxpos) lowrisc_shadow_console_putchar('\b');
+  else if (xpos < oldxpos) lowrisc_shadow_console_putchar('\r');
+  else if (xpos > oldxpos+1) lowrisc_shadow_console_putchar(' ');
+  if (ypos > oldypos) lowrisc_shadow_console_putchar('\n');
+  lowrisc_shadow_console_putchar(c);
+  if (xpos == oldxpos)
+    {
+      lowrisc_shadow_console_putchar('\b');
+      oldxpos = xpos-1;
+    }
+  else
+    oldxpos = xpos;
+  oldypos = ypos;
+#endif
+}
+
+static void lowrisc_con_putcs(struct vc_data *vc, const unsigned short *s, int count, int ypos, int xpos)
+{
+  while (count--) lowrisc_con_putc(vc, *s++, ypos, xpos++);
+}
+
+static void lowrisc_con_cursor(struct vc_data *vc, int mode) { }
+
+static bool lowrisc_con_scroll(struct vc_data *vc, unsigned int top,
+                           unsigned int bottom, enum con_scroll dir,
+                           unsigned int lines)
+{
+  oldypos--;
+#if 0
+  if (lines <= 0)
+    return false;
+
+  if (lines > LOWRISC_ROWS)   /* maximum realistic size */
+    lines = LOWRISC_ROWS;
+
+  switch (dir)
+    {
+
+    case SM_UP:
+      mymove(hid_vga_ptr+top*LOWRISC_COLUMNS, hid_vga_ptr+(top+lines)*LOWRISC_COLUMNS, LOWRISC_MEM-(bottom-top-lines)*LOWRISC_COLUMNS);
+      myset(hid_vga_ptr+(bottom-lines)*LOWRISC_COLUMNS, 0, lines*LOWRISC_COLUMNS);
+      break;
+
+    case SM_DOWN:
+      mymove(hid_vga_ptr+(top+lines)*LOWRISC_COLUMNS, hid_vga_ptr+top*LOWRISC_COLUMNS, LOWRISC_MEM-(bottom-top-lines)*LOWRISC_COLUMNS);
+      myset(hid_vga_ptr+top*LOWRISC_COLUMNS, 0, lines*LOWRISC_COLUMNS);
+      break;
+    }
+
+  return true;
+
+#else
+
+  mymove(hid_vga_ptr, hid_vga_ptr+LOWRISC_COLUMNS, LOWRISC_MEM-LOWRISC_COLUMNS);
+  myset(hid_vga_ptr+LOWRISC_MEM-LOWRISC_COLUMNS, 0, LOWRISC_COLUMNS);
+  return true;
+
+#endif        
+}
+
+static int lowrisc_con_switch(struct vc_data *vc)
+{
+	return 0;
+}
+
+static int lowrisc_con_blank(struct vc_data *vc, int blank, int mode_switch)
+{
+	return 0;
+}
+
+static int lowrisc_con_font_set(struct vc_data *vc, struct console_font *font,
+			     unsigned int flags)
+{
+	return 0;
+}
+
+static int lowrisc_con_font_default(struct vc_data *vc,
+				 struct console_font *font, char *name)
+{
+	return 0;
+}
+
+static int lowrisc_con_font_copy(struct vc_data *vc, int con)
+{
+	return 0;
+}
+
+/*
+ *  The console `switch' structure for the lowrisc console
+ *
+ *  Most of the operations are dummies.
+ */
+
+const struct consw lowrisc_con = {
+	.owner =		THIS_MODULE,
+	.con_startup =	lowrisc_con_startup,
+	.con_init =		lowrisc_con_init,
+	.con_deinit =	lowrisc_con_deinit,
+	.con_clear =	lowrisc_con_clear,
+	.con_putc =		lowrisc_con_putc,
+	.con_putcs =	lowrisc_con_putcs,
+	.con_cursor =	lowrisc_con_cursor,
+        .con_scroll =	lowrisc_con_scroll,
+	.con_switch =	lowrisc_con_switch,
+	.con_blank =	lowrisc_con_blank,
+	.con_font_set =	lowrisc_con_font_set,
+	.con_font_default =	lowrisc_con_font_default,
+	.con_font_copy =	lowrisc_con_font_copy,
+};
+
+static int lowrisc_con_probe(struct platform_device *ofdev)
+{
+        struct resource *lowrisc_vga;
+	int rc = 0;
+
+        lowrisc_vga = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+
+        hid_vga_ptr = devm_ioremap_resource(&ofdev->dev, lowrisc_vga);
+
+	printk(DRIVER_NAME": Lowrisc VGA console (%llX-%llX) mapped to %lx\n",
+               lowrisc_vga[0].start,
+               lowrisc_vga[0].end,
+               (size_t)(hid_vga_ptr));
+
+        console_lock();
+        rc = do_take_over_console(&lowrisc_con, 0, MAX_NR_CONSOLES - 1, 1);
+        console_unlock();
+        
+	return rc;
+}
+
+/* Match table for OF platform binding */
+static const struct of_device_id lowrisc_con_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, lowrisc_con_of_match);
+
+void lowrisc_con_free(struct platform_device *of_dev)
+{
+        struct resource *iomem = platform_get_resource(of_dev, IORESOURCE_MEM, 0);
+        release_mem_region(iomem->start, resource_size(iomem));
+}
+
+int lowrisc_con_unregister(struct platform_device *of_dev)
+{
+        lowrisc_con_free(of_dev);
+        return 0;
+}
+
+static struct platform_driver lowrisc_con_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_con_of_match,
+	},
+	.probe = lowrisc_con_probe,
+	.remove = lowrisc_con_unregister,
+};
+
+module_platform_driver(lowrisc_con_driver);
+
+MODULE_AUTHOR("Jonathan Kimmitt");
+MODULE_DESCRIPTION("Lowrisc VGA-compatible console driver");
+MODULE_LICENSE("GPL");
diff -urN linux-4.18-patched/drivers/video/console/Makefile riscv-linux-riscv-linux-4.18/drivers/video/console/Makefile
--- linux-4.18-patched/drivers/video/console/Makefile	2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/drivers/video/console/Makefile	2018-09-16 09:51:45.372714684 +0100
@@ -4,6 +4,7 @@
 # Rewritten to use lists instead of if-statements.
 
 obj-$(CONFIG_DUMMY_CONSOLE)       += dummycon.o
+obj-$(CONFIG_LOWRISC_VGA_CONSOLE) += lowrisc-con.o
 obj-$(CONFIG_SGI_NEWPORT_CONSOLE) += newport_con.o
 obj-$(CONFIG_STI_CONSOLE)         += sticon.o sticore.o
 obj-$(CONFIG_VGA_CONSOLE)         += vgacon.o
diff -urN linux-4.18-patched/kernel/dma/swiotlb.c riscv-linux-riscv-linux-4.18/kernel/dma/swiotlb.c
--- linux-4.18-patched/kernel/dma/swiotlb.c     2018-08-12 21:41:04.000000000 +0100
+++ riscv-linux-riscv-linux-4.18/kernel/dma/swiotlb.c 2018-09-17 15:23:49.410795216 +0100
@@ -147,7 +147,7 @@
 }
 
 /* default to 64MB */
-#define IO_TLB_DEFAULT_SIZE (64UL<<20)
+#define IO_TLB_DEFAULT_SIZE (1UL<<20)
 unsigned long swiotlb_size_or_default(void)
 {
        unsigned long size;
